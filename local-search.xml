<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>物联网复习</title>
    <link href="/2022/01/09/%E7%89%A9%E8%81%94%E7%BD%91%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/01/09/%E7%89%A9%E8%81%94%E7%BD%91%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="物联网复习"><a href="#物联网复习" class="headerlink" title="物联网复习"></a>物联网复习</h1><p>[toc]</p><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><h3 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章:概述"></a>第一章:概述</h3><h4 id="物联网是什么？"><a href="#物联网是什么？" class="headerlink" title="物联网是什么？"></a>物联网是什么？</h4><p>物联网是通过各种信息传感设备及系统（如传感器网络、射频识别（RFID）、红外感应器、条码与二维码、全球定位系统、激光扫描器等）和其它基于物物通信模式的短距离无线传感网络，按约定的协议，把任何物体通过各种接入网与互联网连接起来所形成的一个巨大的智能网络，通过这一网络可以进行信息交换、传递和通信，以实现对物体的智能化识别、定位、跟踪、监控和管理。</p><p><img src="https://img-blog.csdnimg.cn/798145858f6f483a93c76d417b7abed6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_18,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="物联网的主要特点与相关概念辨析"><a href="#物联网的主要特点与相关概念辨析" class="headerlink" title="物联网的主要特点与相关概念辨析"></a>物联网的主要特点与相关概念辨析</h4><p><img src="https://img-blog.csdnimg.cn/cbd4dbed2fae4857af579c954827ddd2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>互联网</strong>：即对需要联网的物一定要能够实现互联互通的互联网络。</p><p><strong>识别与通信</strong>：即纳入联网的“物”一定要具备自动识别与物物通信（M2M）的功能。</p><p><strong>智能化</strong>：即网络系统应该具有自动化、自我反馈与智能控制的特点。</p><p>“<strong>E”社会</strong>，能够实现任何人和任何人在任何时候、任何地点的通信与联系，“三A通信”（Anyone，Anytime，Anywhere），其衡量标准主要有电话普及率、互联网普及率以及计算机普及率。</p><p>“<strong>U”社会</strong>，能够实现任何人和任何人、任何人和任何东西（对象）在任何时候和任何地点的通信与联系，即“四A通信”（Anyone，Anytime，Anywhere,Anything）。其是一个“人-机-物”组成的动态开放的网络社会，即人类社会、信息世界、物理世界组成的三元世界。</p><p><strong>互联网</strong>：连接虚拟信息空间（信息挖掘与共享）</p><p><strong>传感网</strong>：连接现实物理世界（信息获取与感知）<br><img src="https://img-blog.csdnimg.cn/a0743df071cb4db98aabc3c0d47732d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="物联网体系结构"><a href="#物联网体系结构" class="headerlink" title="物联网体系结构"></a>物联网体系结构</h4><p>根据信息生成、传输、处理和应用的原则，可以把物联网分为四层：<strong>感知识别层、网络构建层、管理服务层和综合应用层。</strong></p><p><img src="https://img-blog.csdnimg.cn/29d742d5beb04a60adf4c8341d95b88d.png" alt="在这里插入图片描述"></p><p>科技界普遍认为，<strong>信息技术</strong>由四大部分组成，即<strong>信息获取、信息传输、信息处理与信息应用或信息利用</strong>，这四部分实际上组成了如图的一个完整信息链。<strong>检测技术</strong>的重点是在信息的获得，<strong>通信技术</strong>的重点是在信息的传输，<strong>计算机技术</strong>的重点是在信息的处理，<strong>自动化技术</strong>的重点则在信息的应用。</p><p><strong>以传感器网络为核心的参考体系架构</strong>–该架构分为三层<br><img src="https://img-blog.csdnimg.cn/846b992677d04f0b931f58ad8ce504e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>！！！感觉这个概念会结合实验考！！！</p><p>从物联网的<strong>逻辑结构</strong>看，物联网分为<strong>传感层、网络层和应用层</strong>三个部分。而从物联网的<strong>物理架构</strong>看，一个物联网系统往往包括<strong>物联网感知识别设备</strong>、<strong>物联网网关</strong>、<strong>物联网云平台</strong>和<strong>用户端</strong>四个部分。</p><h4 id="物联网的应用场景"><a href="#物联网的应用场景" class="headerlink" title="物联网的应用场景"></a>物联网的应用场景</h4><p>智能家居，智能医疗，智能城市，智能环保，智能交通，智能工业，智能农业 ，智能物流， 智能社区，智能会展 </p><h3 id="第二章-自动识别技术"><a href="#第二章-自动识别技术" class="headerlink" title="第二章:自动识别技术"></a>第二章:自动识别技术</h3><p><strong>个人感觉这章最重要的就是条码和RFID把这两块好好看看</strong></p><p><strong>自动识别技术</strong>是应用一定的识别装置，识读装置自动地获取被识别物品的相关信息，并提供给后台的计算机处理系统来完成相关后续处理的一种技术。</p><h4 id="自动识别技术的种类："><a href="#自动识别技术的种类：" class="headerlink" title="自动识别技术的种类："></a>自动识别技术的种类：</h4><p>自动识别技术包含条形码技术，射频识别，机器视觉识别和生物识别技术。</p><h4 id="条形码技术：最早的也是最出名最成功的自动识别技术。"><a href="#条形码技术：最早的也是最出名最成功的自动识别技术。" class="headerlink" title="条形码技术：最早的也是最出名最成功的自动识别技术。"></a>条形码技术：最早的也是最出名最成功的自动识别技术。</h4><p><strong>条形码</strong>(Bar Code）是由一组按一定编码规则排列的条、空符号组成的编码符号，用以表示一定的字符、数字及符号组成的信息。</p><h5 id="条形码的分类："><a href="#条形码的分类：" class="headerlink" title="条形码的分类："></a>条形码的分类：</h5><p><strong>按维数条形码可分为一维条形码、二维条形码、多维条形码等</strong></p><p>•<strong>一维条形码</strong>只是在一个方向（一般是水平方向）表达信息，而在垂直方向则不表达任何信息；</p><p>•<strong>一维条形码</strong>的应用可以提高信息录入的速度，减少差错率；</p><p>•<strong>一维条形码</strong>存在数据容量较小（30个字符左右）、只能包含字母和数字、条形码尺寸相对较大（空间利用率较低）、条形码遭到损坏后便不能阅读等。</p><p>•<strong>二维条形码</strong>在平面的横向和纵向上都能表示信息，与一位条形码比较，二维码所携带的信息量和信息密度都提高了几倍；</p><p>•<strong>二维条形码</strong>可表示图像、文字、甚至声音。</p><p><strong>二维码（</strong>Bar-code）是用某种特定的几何图形按一定规律在平面（二维方向）分布的黑白相间的图形记录数据符号信息的，具有一定的校验功能，同时还具有对不同行的信息自动识别功能、及处理图形旋转变化等特点。</p><h5 id="二维码分类"><a href="#二维码分类" class="headerlink" title="二维码分类"></a>二维码分类</h5><p>1.<strong>线性堆叠式二维码</strong>：是在一维条形码编码原理的基础上，将多个一维码在纵向堆叠而产生的。</p><p>2.<strong>矩阵式二维码</strong>：是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。</p><p>3.<strong>邮政码</strong>：通过不同长度的条进行编码，主要用于邮件编码。</p><h4 id="射频识别：即RFID技术，也称电子标签、无线射频识别"><a href="#射频识别：即RFID技术，也称电子标签、无线射频识别" class="headerlink" title="射频识别：即RFID技术，也称电子标签、无线射频识别"></a>射频识别：即RFID技术，也称电子标签、无线射频识别</h4><p><strong>RFID</strong> 是一项易于操控、简单实用且特别适合用于自动化控制的灵活性应用技术。它既可支持只读工作模式，也可支持读写工作模式，且无须接触或瞄准；可自由工作在各种恶劣环境下；可进行高度的数据集成。</p><h5 id="对比条形码技术"><a href="#对比条形码技术" class="headerlink" title="对比条形码技术"></a>对比条形码技术</h5><p><strong>和传统条形码识别技术相比，RFID <strong>有以下</strong>优势</strong>：</p><p>1.<strong>快速扫描</strong>，2.<strong>体积小、形状多样化</strong>，3.<strong>抗污染能力和耐久性</strong>，4.<strong>可重复使用</strong>，5.<strong>穿透性和无屏障阅读</strong> ，6.<strong>数据记忆容量大</strong>，7.<strong>安全性</strong></p><h5 id="射频识别系统的组成"><a href="#射频识别系统的组成" class="headerlink" title="射频识别系统的组成"></a>射频识别系统的组成</h5><p>如下图所示，射频识别系统包括有<strong>电子标签</strong>，<strong>阅读器（读写器）</strong>，<strong>天线</strong>三个部分</p><p>–<strong>电子标签（</strong>Tag、射频标签、应答器）：由芯片及内置天线组成</p><p>–<strong>阅读器（读写器）：</strong>读取或读/写电子标签信息的设备</p><p>–<strong>天线</strong> <strong>：</strong>标签与阅读器之间传输数据的发射、接收装置</p><p><img src="https://img-blog.csdnimg.cn/8c26e4060ce140e88068ab07e7b95220.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h5 id="射频识别系统的主要技术"><a href="#射频识别系统的主要技术" class="headerlink" title="射频识别系统的主要技术"></a>射频识别系统的主要技术</h5><p>  <strong>RFID</strong> <strong>技术</strong>研究主要集中在<strong>工作频率选择</strong>、<strong>天线设计</strong>、<strong>防冲突技术</strong>和<strong>安全与隐私保护</strong>等方面。</p><p><strong>1.工作频率选择问题</strong></p><p>  <strong>低频频段：</strong>能量相对较低，数据传输率较小，无线覆盖范围受限。<strong>优点</strong>天线的方向性不强，具有相对较强的<strong>绕开障碍物能力</strong>。</p><p>  <strong>高频频段：</strong>能量相对较高，适于长距离应用。<strong>缺点</strong>是<strong>容易被障碍物所阻挡</strong>，易受反射和人体扰动等因素影响，<strong>不易实现无线作用范围的全区域覆盖</strong>。</p><p><strong>高频频段数据传输率相对较高，且通信质量较好。</strong></p><p><img src="https://img-blog.csdnimg.cn/70827566ae2045a1b4f89db32179b158.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>2.防冲突技术–ALOHA算法</strong></p><p><strong>ALOHA 算法</strong>是一种随机接入方法，当任意一个<strong>标签</strong>接收到<strong>阅读器广播</strong>的识别命令之后，立即以定长信息包形式向<strong>阅读器</strong>发送其表示符号，在标签<strong>发送数据的过程中</strong>，若有<strong>其他标签</strong>也在发送标识符，则它们之间的信号发送叠加导致冲突或部分冲突。阅读器接受到信号之后，检测是否有冲突发生。如没有冲突发生，阅读器正确识别标签标识符并发送确认消息；<strong>如果发生冲突</strong>，阅读器就发送冲突确认，标签接收到冲突确认之后随机独立地等待一段时间后再重新发送以避免冲突，直到发送成功为止。</p><p><strong>3.安全与隐私</strong></p><p>  RFID安全问题集中在对个人用户的隐私保护、对企业用户的商业秘密保护、防范对RFID系统的攻击以及利用RFID 技术进行安全防范等多个方面。</p><p>1.<strong>保证用户对标签的拥有信息不被未经授权访问</strong>，以保护用户在消费习惯、个人行踪等方面的隐私。</p><p>2.<strong>避免</strong>由于RFID 系统读取速度快，而<strong>被利用来窃取用户商业机密。</strong></p><p>3.<strong>防护对</strong>RFID <strong>系统的各类攻击。</strong>如：重写标签以窜改物品信息；使用特制设备伪造标签应答欺骗读写器以制造物品存在的假相；根据RFID 前后向信道的不对称性远距离窃听标签信息；通过干扰RFID 工作频率实施拒绝服务攻击；通过发射特定电磁波破坏标签等。</p><p>4.<strong>把</strong>RFID <strong>的唯一标识特性用于门禁安防、支票防伪、产品防伪</strong>等。</p><h4 id="机器视觉识别：用机器代替人眼来进行测量和判断。"><a href="#机器视觉识别：用机器代替人眼来进行测量和判断。" class="headerlink" title="机器视觉识别：用机器代替人眼来进行测量和判断。"></a>机器视觉识别：用机器代替人眼来进行测量和判断。</h4><h4 id="生物识别技术：利用可以测量的人体生物学或行为学特征来核实个人身份。"><a href="#生物识别技术：利用可以测量的人体生物学或行为学特征来核实个人身份。" class="headerlink" title="生物识别技术：利用可以测量的人体生物学或行为学特征来核实个人身份。"></a>生物识别技术：利用可以测量的人体生物学或行为学特征来核实个人身份。</h4><p>每个人都有自身固有的生物特征，人体生物特征具有“人人不同，终身不变，随身携带”的特点。由于人体特征具有人体所固有的不可复制的唯一性，这一生物<a href="http://baike.baidu.com/view/934.htm">密钥</a>无法复制，失窃或被遗忘，生物识别技术就是利用生物特征或行为特征对个人进行身份识别，利用生物识别技术进行身份认定，安全、可靠、准确。</p><p><strong>生物识别技术</strong>主要包括：<strong>手形识别</strong>，<strong>面相识别技术</strong>，<strong>签名识别</strong>，<strong>虹膜识别技术</strong>，<strong>声音识别技术</strong>，<strong>掌纹识别技术</strong>，<strong>真皮层特征识别</strong>，<strong>静脉特征识别</strong>，<strong>指纹识别</strong>，<strong>声纹识别等等</strong></p><p><strong>指纹识别</strong>指纹识别即指通过比较不同指纹的细节特征点来进行鉴别。由于每个人的指纹不同，就是同一个人的十指之间，指纹也有明显区别，因此指纹可用于身份鉴定。</p><h3 id="第三章-传感器与传感网"><a href="#第三章-传感器与传感网" class="headerlink" title="第三章:传感器与传感网"></a>第三章:传感器与传感网</h3><p>传感器（Sensor；Measuring Element；Transducer）是一种检测装置，能感受到被测量的信息，并能将检测感受到的信息，按一定规律变换成为电信号或其他所需形式的信息输出，以满足信息的传输、处理、存储、显示、记录和控制等要求。它是实现自动检测和自动控制的首要环节，也是物联网获取物理世界信息的基本手段。国家标准 GB7665-87 对传感器下的定义是：“能感受规定的被测量并按照一定的规律转换成可用信号的器件或装置，通常由敏感元件和转换元件组成”。</p><h4 id="传感器分类"><a href="#传感器分类" class="headerlink" title="传感器分类"></a>传感器分类</h4><p>按传感器的<strong>物理量分类</strong>，可分为位移、力、速度、温度、流量、气体成份等传感器。</p><p>按传感器<strong>工作原理分类</strong>，可分为电阻、电容、电感、电压、霍尔、光电、光栅热电偶等传感器。</p><p>按传感器输<strong>出信号的性质分类</strong>，可分为：输出为开关量（“１” 和“０”或“开”和“关”）的开关型传感器；输出为模拟量的模拟型传感器；输出为脉冲或代码的数字型传感器。</p><p><img src="https://img-blog.csdnimg.cn/23fcde6c4f834c4f9acc80464ebd1cd7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="无线传感网"><a href="#无线传感网" class="headerlink" title="无线传感网"></a>无线传感网</h4><p><strong>无线传感器网络</strong>（Wireless Sensor Network，WSN）由部署在监测区域内的传感器节点组成，这些节点数量很大、体积微小，通过<strong>无线通信</strong>方式形成一个<strong>多跳的自组织网络</strong>。 </p><p>无线传感网是物联网的基本组成部分，可以将客观物理世界与信息世界融合在一起，能够改变人与自然界的交互方式，极大地扩展现有网络的功能和人类认识世界的能力</p><h4 id="传感器和传感网络节点的区别"><a href="#传感器和传感网络节点的区别" class="headerlink" title="传感器和传感网络节点的区别"></a>传感器和传感网络节点的区别</h4><p>一个传感器和一个传感网络节点的<strong>区别在于是否植入了一个通信模块</strong>。<strong>传感器节点</strong>是无线传感器网络的基本功能单元。传感器节点可采用自组织方式进行组网，利用无线（有线）通信技术进行数据转发的，节点都具有数据采集与数据融合转发双重功能。</p><h3 id="第四章-近距离无线通信技术"><a href="#第四章-近距离无线通信技术" class="headerlink" title="第四章:近距离无线通信技术"></a>第四章:近距离无线通信技术</h3><p><strong>无线通信（Wireless Communication）</strong>是利用电磁波信号可以在空间传播的特性进行信息交换的一种通信方式。无线通信包括<strong>固定体之间的无线通信</strong>和<strong>移动通信</strong>两大部分。由于人类社会活动具有的显著的移动性，因而<strong>移动通信</strong>在无线通信中占主导地位。<strong>移动通信</strong>就是移动体之间的通信，或移动体与固定体之间的通信。</p><p><strong>近距离无线通信技术：</strong>范围很广，在一般意义上，只要通信收发双方通过无线电波传输信息，并且传输距离限制在较短的范围内，通常是几十米以内，就可以称为近（短）距离无线通信。</p><h4 id="常用的近距离无线通信技术"><a href="#常用的近距离无线通信技术" class="headerlink" title="常用的近距离无线通信技术"></a>常用的近距离无线通信技术</h4><table><thead><tr><th>蓝牙</th><th>Wibree</th><th>Wi-Fi</th><th>WiGig(60GHz)</th><th>IrDA</th></tr></thead><tbody><tr><td>ZigBee</td><td>NFC</td><td>UWB</td><td>Z-Wave</td><td></td></tr></tbody></table><h4 id="蓝牙介绍"><a href="#蓝牙介绍" class="headerlink" title="蓝牙介绍"></a>蓝牙介绍</h4><p><strong>蓝牙</strong>：蓝牙（Bluetooth）是一种无线数据与语音通信的开放性全球规范，它以低成本的短距离无线连接为基础，可为固定的或移动的终端设备(如掌上电脑、笔记本电脑和手机等)提供廉价的接入服务。由于<strong>蓝牙体积小、功率低</strong>，其应用已不局限于计算机外设，几乎<strong>可以被集成到任何数字设备之中</strong>，<strong>特别是</strong>那些<strong>对数据传输速率要求不高的移动设备和便携设备</strong>。</p><p><strong>蓝牙特点：</strong></p><p>1.全球范围适用，2.可同时传输语音和数据，3.可以建立临时性的对等连接（Ad-hoc Connection)，4.具有很好的抗干扰能力，5.蓝牙模块体积很小、便于集成，6.低功耗，7.开放的接口标准，8.成本低</p><p><strong>蓝牙无线技术的应用大体上可以划分为</strong></p><p><strong>1.替代线缆（Cable Replacement）</strong></p><p>与其他短距离无线技术不同，蓝牙从一开始就定位于结合语音和数据应用的基本传输技术。最简单的一种应用就是点对点（Point to Point）的替代线缆，例如耳机和移动电话、笔记本电脑和移动电话、PC和PDA（数据同步）、数码相机和PDA以及蓝牙电子笔和移动电话之间的无线连接。 围绕替代线缆再复杂一点的应用，就是多个设备或外设在一个简单的“个人局域网”（PAN）内建立通信连接，如在台式计算机、鼠标、键盘、打印机、ＰＤＡ和移动电话之间建立无线连接。为了支持这种应用，蓝牙还定义了“微网”（Piconet）的概念，同一个ＰＡＮ内至多有8个数据设备（1个“主设备”（Master）和7个“从设备”（Slave））共存。 </p><p><strong>2.因特网桥（Internet Bridge）</strong></p><p>蓝牙标准还更进一步地定义了“网络接入点”（Network Access Point）的概念，它允许一台设备通过此网络接入点来访问网络资源，如访问LAN、Intranet、Internet和基于ＬＡＮ的文件服务和打印设备。 </p><p><strong>3.临时组网（Ad Hoc Network）</strong></p><p>蓝牙标准还定义了基于无网络基础设施（Infrastructure-less Network）的“散型网”（Scatternet）的概念，意在建立完全对等（P2P）的Ad Hoc Network。所谓的Ad Hoc Network是一个临时组建的网络，其中没有固定的路由设备，网络中所有的节点都可以自由移动，并以任意方式动态连接（随时都有节点加入或离开），网络中的一些节点客串路由器来发现和维持与网络其他节点间的路由。</p><p><strong>蓝牙技术规定两个设备进行蓝牙通信时，必须将设备分为“主端”和“从端”才可以。且可以在两个角色间切换。主端模式向其它设备发起连接请求。蓝牙客户端用来发起通信链接请求，而蓝牙服务端负责接受通信连接请求。</strong></p><h4 id="NFC介绍"><a href="#NFC介绍" class="headerlink" title="NFC介绍"></a>NFC介绍</h4><p><strong>NFC</strong>英文全称<strong>Near Field Communication</strong>，即近场通信技术。NFC是脱胎于无线设备间的一种“非接触式射频识别”(RFID)及互联技术，为所有消费性电子产品提供了一个极为便利的通讯方式。NFC在数厘米（通常是15cm以内）距离之间于13.56MHz频率范围内运作，通过射频信号自动识别目标对象并获取相关数据，识别工作无须人工干预，任意两个设备（如移动电话）接近而不需要线缆接插，就可以实现相互间的通信，满足任何两个无线设备间的信息交换、内容访问、服务交换。</p><p> <strong>NFC工作原理</strong></p><p>NFC存在两种工作模式：<strong>主动模式</strong>和<strong>被动模式。</strong>在<strong>主动模式</strong>下，每台设备要向另一台设备发送数据时，都必须产生自己的射频场。发起设备和目标设备都要产生自己的射频场，以便进行通信。这是对等网络通信的标准模式，可以获得非常快速的连接设置。在<strong>被动模式</strong>下，启动NFC通信的设备，也称为NFC发起设备（主设备），在整个通信过程中提供射频场（RF field）。</p><h3 id="第五章-云计算与大数据技术基础"><a href="#第五章-云计算与大数据技术基础" class="headerlink" title="第五章:云计算与大数据技术基础"></a>第五章:云计算与大数据技术基础</h3><p>云计算与物联网、大数据有重要的关联性，作为未来的人机物计算的重要组成部分，云计算关注的是基础设施和服务器端，大数据是内容，物联网关注的客户和终端技术</p><h4 id="什么是云计算？"><a href="#什么是云计算？" class="headerlink" title="什么是云计算？"></a>什么是云计算？</h4><p><strong>云计算是通过集中式远程计算资源池，以按需分配方式，为终端用户提供强大而廉价的计算服务能力</strong></p><h4 id="云计算解决什么实际问题？"><a href="#云计算解决什么实际问题？" class="headerlink" title="云计算解决什么实际问题？"></a>云计算解决什么实际问题？</h4><p>用一个集中管理的巨大的计算资源池，提供巨大的计算资源和能力<strong>1.为小粒度应用提供资源共享；2.为大粒度应用提供大规模计算能力</strong></p><h4 id="云计算的主要特点"><a href="#云计算的主要特点" class="headerlink" title="云计算的主要特点"></a>云计算的主要特点</h4><p>透明的云端计算服务；“<strong>无限”多</strong>的计算资源，提供强大的计算能力；<strong>按需分配，弹性伸缩，取用方便，成本低廉</strong>；资源共享，降低企业IT基础设施建设维护费用；应用部署快速而容易；软件/应用功能更新方便快捷；节省能源，绿色环保；集计算技术之大成，具有很强的技术性、工程型特点。</p><p><strong>按云计算服务层面进行分类</strong></p><p><strong>SaaS</strong>：Software as a Service；提供各种应用软件服务</p><p><strong>PaaS</strong>：Platform as a Service；提供软件支撑平台服务</p><p><strong>IaaS</strong>：Infrastructure as a Service；提供接近于裸机(物理机或虚拟机)的计算资源和基础设施服务</p><p><strong>例如咱们学习的邮箱就是Saas的一种形式</strong></p><p><img src="https://img-blog.csdnimg.cn/d8a8ce891a8842b9b46bbbc7738fcf08.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="云计算发展趋势"><a href="#云计算发展趋势" class="headerlink" title="云计算发展趋势"></a>云计算发展趋势</h4><p><strong>云计算将提供一种新的计算模式和服务模式</strong>。云计算将是计算技术的一次重大变革，作为今后计算发展的潮流将大大改变现有的计算模式，对计算技术领域本身以及各个应用行业都将带来重大的影响，提供更多的发展机遇。<strong>通过云计算人们能获得前所未有的强大计算能力，并能按需分配，按需付费</strong>，提升了本地计算能力但使用成本低廉，而且还能大幅削减不断升级软硬件系统的费用。<strong>通过云计算平台强大的计算和存储能力，人们将能完成传统系统所无法完成的计算和处理</strong>，开发出更强大的应用功能，提供更多智能化应用  。<strong>云计算与物联网、大数据有重要的关联性</strong>，作为未来的人机物计算的重要组成部分，云计算关注的是基础设施和服务器端，大数据是内容，物联网关注的客户和终端技术，通过各种个人终端使用云端的计算能力，将大大扩展现有的移动设备的计算能力，提供各种新的增值应用模式</p><h4 id="什么是“大数据”？"><a href="#什么是“大数据”？" class="headerlink" title="什么是“大数据”？"></a>什么是“大数据”？</h4><p> 大数据意指一个超大的、难以用现有常规的数据库管理技术和工具处理的数据集</p><p><strong>数据科学</strong>  <strong>实验科学-&gt;理论科学 -&gt;计算科学 -&gt;数据科学</strong></p><p><strong>大数据特点:</strong> 5V</p><p>  <strong>Volume: 大容量, Variety: 多样性,Velocity: 时效性,Veracity: 准确性, Value: 大价值</strong></p><h4 id="大数据处理的两大技术挑战"><a href="#大数据处理的两大技术挑战" class="headerlink" title="大数据处理的两大技术挑战"></a>大数据处理的两大技术挑战</h4><p><strong>如何存？数据存储问题</strong>–数据规模导致难以应对的存储量</p><p><strong>解决方法：分布存储</strong></p><p><strong>如何算？计算性能问题</strong>–数据规模导致传统算法失效–复杂的数据关联性导致高复杂度的计算</p><p><strong>解决方法：并行计算</strong></p><p><strong>大数据研究的基本途径</strong></p><p><strong>三个基本途径</strong>：1.寻找新算法降低计算复杂度2.降低大数据尺度，寻找数据尺度无关算法3.大数据并行化处理</p><h3 id="第六章-定位系统"><a href="#第六章-定位系统" class="headerlink" title="第六章:定位系统"></a>第六章:定位系统</h3><p>在物联网中，定位就是确定物体的方位。定位按照使用场景不同，可以划分为<strong>室外定位</strong>和<strong>室内定位</strong>两大类。</p><h4 id="室外定位技术"><a href="#室外定位技术" class="headerlink" title="室外定位技术"></a>室外定位技术</h4><p><strong>室外定位</strong>主要是<strong>卫星定位</strong>和<strong>基站定位</strong>。卫星定位即采用全球卫星导航系统（Global Navigation Satellite System, GNSS）实现定位，但由于建筑物遮挡卫星信号，卫星定位在室内无法实现。</p><p><strong>位置信息三要素</strong>：所在的地理位置，处在该地理位置的时间，处在该地理位置的对象（人或设备）</p><p><strong>现有定位系统</strong>：现阶段，世界上主要有四种卫星导航定位系统，分别为美国的全球卫星定位系统（GPS系统），俄罗斯的全球导航卫星系统（GLONASS系统），中国的北斗卫星定位系统，以及欧洲的伽利略系统（GALILEO系统）。</p><p>GPS可以提供的信息：（１）地球表面的位置（２）所处位置的高度（３）航行的速度及方向（４）时间</p><p>GPS定位原理：1.GPS的定位原理是通过四颗已知位置的卫星来确定GPS接收器的位置。2.三维坐标（经度、纬度、高度），至少需要4颗GPS卫星。3.求解４个未知量，经度、维度、高度和接收机时钟误差。</p><p><strong>GPS三个主要部分</strong></p><p><strong>空间部分</strong>：由24 颗工作卫星组成，它们均匀分布在6 个轨道面上（每个轨道面4 颗），卫星的分布使得在全球任何地方、任何时间都可观测到4 颗以上的卫星，并能保持良好定位解算精度的几何图象；</p><p><strong>控制部分</strong>：主要由监测站、主控站、备用主控站、信息注入站构成，主要负责GPS卫星阵的管理控制；</p><p><strong>用户设备部分</strong>：主要是GPS接收机，主要功能是接收GPS卫星发射的信号，获得定位信息和观测量，经数据处理实现定位。</p><p><img src="https://img-blog.csdnimg.cn/e9f99511ebe348ffa44c934060730950.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>A-GPS技术</strong>：A-GPS（Assisted GPS）即辅助GPS技术，它可以提高 GPS 卫星定位系统的性能。通过移动通信运营基站它可以快速地定位，广泛用于含有GPS功能的手机上。GPS通过卫星发出的无线电信号来进行定位。当在很差的信号条件下，例如在一座城市，这些信号可能会被许多不规则的建筑物、墙壁或树木削弱。在这样的条件下，非A-GPS 导航设备可能无法快速定位，而A-GPS 系统可以通过运营商基站信息来进行快速定位。</p><p><strong>蜂窝基站定位</strong>：蜂窝通信，是一种小区制移动通信，在每个小区设立一个基站（Base Station），用户手机与基站通过无线链路建立连接，从而实现双向通信。</p><p>（1）小区制将整个区域划分成若干个小区，多个小区组成一个区群。由于区群结构酷似蜂窝，因此小区制移动通信系统也叫蜂窝移动通信系统。</p><p>（2）小区内的基站架设一个或几个，手机与基站建立无线链路。</p><p>（3）区群中各小区基站之间通过光缆、电缆或微波链路与移动交换中心连接。</p><p><strong>移动设备在GSM网络通信原理</strong></p><p>用移动设备在GSM网络中通信，实际上就是通过某一个蜂窝基站接入GSM网络，然后通过GSM网络进行数据（语音数据、文本数据、多媒体数据等）传输的。也就是说我们在GSM中通信时，总是需要和某一个蜂窝基站连接的，或者说是处于某一个蜂窝小区中的。那么GSM定位，就是借助这些蜂窝基站进行定位。</p><p><strong>COO（Cell of Origin）定位</strong></p><p>COO定位是一种<strong>单基站定位</strong>，即根据设备当前连接的蜂窝基站的位置来确定设备的位置。那么很显然，定位的精度就取决于蜂窝小区的半径。在基站密集的城市中心地区，通常会采用多层小区，小区划分的很小，这时定位精度可以达到50M以内；而在其他地区，可能基站分布相对分散，小区半径较大，可能达到几千米，也就意味着定位精度只能粗略到几千米。目前Google地图移动版中，通过蜂窝基站确定“我的位置”，基本上用的就是这种方法。</p><p><strong>TOA/TDOA定位</strong></p><p>TOA(Time of Arrival，到达时间)、TDOA(Time Difference of Arrival,到达时间差)都是基于电波传播时间的定位方法。同时也都是三基站定位方法，二者的定位都需要同时有三个位置已知的基站合作才能进行。</p><p>TOA/DTOA定位方法都是通过三对[Positioni,Ti]（i=1,2,3）来确定设备的位置Location。二者的不同只是GetLocation（）函数的具体算法上的不同。TOA电波到达时间定位基本原理是得到Ti(i=1,2,3)后，由Ti<em>c得到设备到基站i之间的距离Ri，然后根据几何只是建立方程组并求解，从而求得Location值。因此TOA算法对<strong>系统的时间同步要求很高</strong>，任何<strong>很小的时间误差</strong>都会被放大很多倍，同时由于<strong>多径效应</strong>的影响又会带来<strong>很大的误差</strong>，因而单纯的TOA在实际中应用很少。<strong>DTOA电波到达时间差定位</strong>是对TOA定位的<strong>改</strong>进，与TOA的不同之处在于，得到Ti后不是立即用Ti去求距离Ri，而是先对T1,T2,T3两两求差，然后通过一些巧妙的数学算法建立方程组并求解，从而得到Location值。DTOA由于其中巧妙设计的求差过程会<strong>抵消</strong>其中<strong>很大一部分的时间误差和多径效应带来的误差</strong>，因而可以*<em>大大提高定位的精确度。</em></em></p><p><img src="https://img-blog.csdnimg.cn/9a2e692ae8dc4b299648812c226cad71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>AOA定位</strong></p><p>AOA(Angle of Arrival，到达角度)定位是一种两基站定位方法，基于信号的入射角度进行定位。</p><h4 id="室内定位技术"><a href="#室内定位技术" class="headerlink" title="室内定位技术"></a>室内定位技术</h4><p>室内定位即通过技术手段获知人们在室内所处的实时位置或者行动轨迹。基于这些信息能够实现多种应用。</p><p><img src="https://img-blog.csdnimg.cn/9b869a4c1fd54ab8b7d928c7934aec4a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><del>这里我感觉就算原理不明白这些方法名字也得记住</del></p><p>从原理上主要分为七种：<strong>邻近探测法、质心定位法、多边定位法、三角定位法、极点法、指纹定位法和航位推算法</strong>。不同的室内定位方法选择不同的观测量，通过不同的观测量提取算法所需要的信息。</p><p><strong>1.临近探测法</strong></p><p><strong>临近探测法</strong>，通过一些有范围限制的物理信号的接收，从而判断移动设备是否出现在某一个发射点附近。该方法虽然只能提供大概的定位信息，但其布设成本低、易于搭建，适合于一些对定位精度要求不高的应用，例如自动识别系统用于公司的员工签到。</p><p><strong>2.质心定位法</strong></p><p><strong>质心定位法</strong>，根据移动设备可接收信号范围内所有已知的信标（beacon）位置，计算其质心坐标作为移动设备的坐标。该方法易于理解，计算量小，定位精度取决于信标的布设密度。</p><p><strong>3.多边定位法</strong></p><p><strong>多边定位法</strong>，通过测量待测目标到已知参考点之间的距离，从而确定待测目标的位置。<strong>优点：</strong>精度高、应用广。</p><p><strong>4.三角定位法</strong></p><p><strong>三角定位法</strong>，该方法是在获取待测目标相对２个已知参考点的角度后结合两参考点间的距离信息可以确定唯一的三角形，即可确定待测目标的位置。<strong>优点</strong>：精度高、应用广。</p><p><strong>5.极点法</strong></p><p><strong>极点法</strong>，通过测量相对某一已知参考点的距离和角度从而确定待测点的位置。该方法仅需已知一个参考点的位置坐标，因此使用非常方便，已经在大地测量中得到广泛应用。</p><p><strong>6.指纹定位法</strong></p><p><strong>指纹定位法</strong>，在定位空间中建立指纹数据库，通过将实际信息与数据库中的参数进行对比来实现定位。指纹定位的优势是几乎不需要参考测量点，定位精度相对较高；但缺点是前期离线建立指纹库的工作量巨大，同时很难自适应于环境变化较大的场景。</p><p><strong>7.航位推算法</strong></p><p><strong>航位推算法</strong>，是在已知上一位置的基础上，通过计算或已知的运动速度和时间计算得到当前的位置。数据稳定，无依赖，但该方法存在累积误差，定位精度随着时间增加而恶化。</p><h5 id="室内定位的观测量"><a href="#室内定位的观测量" class="headerlink" title="室内定位的观测量"></a>室内定位的观测量</h5><p>不同的室内定位方法选择不同的观测量，通过不同的观测量提取算法所需要的信息。</p><p><strong>RSSI测量</strong>:它是通过计算信号的传播损耗，可以使用理论或者经验模型来将传播损耗转化为距离，也可以用于指纹定位建立指纹库。</p><p><strong>TOA测量</strong>:该方法主要测量信号在基站和移动台之间的单程传播时间或来回传播时间。前者要求基站与移动台间的时钟同步。</p><p><strong>TDOA测量</strong>:该方法同样是测量信号到达时间，但使用到达时间差进行定位计算，可利用双曲线交点确定移动台位置，故可以避免对基站和移动台的精确同步。</p><p><strong>AOA测量</strong> :该方法是指接收机通过天线阵列测出电磁波的入射角度，包括测量基站信号到移动台的角度或者移动台信号到达基站的角度。每种方式均会产生从基站到移动台的方向线。2个基站可以得到2条方向线，其交点即为移动台位置。因此，AOA方法只需要2个基站即可确定移动台位置。</p><p><strong>方向和距离</strong>:获取方向和距离多用于航位推算定位，采用自包含传感器记录载体的物理信息，计算得到方向和距离，从而在已知上一位置的基础上计算得到当前的位置。</p><p><strong>当前主流室内定位方法</strong>：WiFi定位技术、FRID定位技术、红外定位技术、超声波定位技术、蓝牙定位技术、惯性导航技术、超宽带(UWB)定位技术、LED可见光定位技术、地磁定位技术、视觉定位。</p><p><img src="https://img-blog.csdnimg.cn/364b32393ee04e998d92835cdc61c8f1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="第七章-智能信息设备"><a href="#第七章-智能信息设备" class="headerlink" title="第七章:智能信息设备"></a>第七章:智能信息设备</h3><p> <strong>手持移动设备</strong></p><p><strong>终端</strong>（Computer terminal），是一台电子计算机或者计算机系统，用来让用户输入数据，及显示其计算结果的机器。终端有些是全电子的，也有些是机电的。其又名终端机，它与一部独立的电脑不同。终端其实就是一种输入输出设备，相对于计算机主机而言属于外设，本身并不提供运算处理功能。<strong>而智能终端设备是指那些具有多媒体功能的智能设备这些设备支持音频、视频、数据等方面的功能</strong>如：可视电话、会议终端、内置多媒体功能的PC<strong>、PDA等。这些终端之所以被称为“智能”是因为该终端内置处理器，它们能够理解转义序列，可以定位光标和控制显示位置。</strong></p><p><img src="https://img-blog.csdnimg.cn/e4807e5eb828427d9b8bd2d0fc5ca128.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAS3JlYWxIdHowLjA=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>华为HMS是Huawei Mobile Service的缩写，翻译过来就是“华为移动服务”。</strong></p><p>鸿蒙OS实现模块化耦合，对应不同设备可<strong>弹性部署</strong>，鸿蒙OS有三层架构，第一层是内核，第二层是基础服务，第三层是程序框架 。可用于大屏、PC、汽车等各种不同的设备上。还可以随时用在手机上，但暂时华为手机端依然优先使用安卓。若安卓应用重新编译，在华为鸿蒙OS操作系统上，运行性能提升超过60%。 华为鸿蒙率先应用在智能手表、智慧屏、车载设备、智能音箱等智能终端上，着力构建一个跨终端的融合共享生态，重塑安全可靠的运行环境。</p><p>HarmonyOS 是“第一个适用于所有场景的基于微内核的分布式操作系统”，它可以运行在智能手机、智能扬声器、计算机、智能手表、无线耳塞、汽车与平板电脑上，其支持的 RAM 大小从千字节到千兆字节不HarmonyOS系统最终将支持一系列应用，兼容 Linux 与 Android 应用，同时该系统应用程序开发中使用的方舟编译器（ArkCompiler）也将支持 Kotlin、Java、JavaScript、C 与 C++。</p><p><strong>内核是所有计算机的核心，是控制一切的基本程序。这里的“微”指的是非常小规模的东西。作为微内核，Fuchsia 可以在任何设备上运行，包括传统的电脑、手机和物联网设备（如冰箱或微波炉）。</strong></p><h3 id="第八章-物联网应用层通信协议"><a href="#第八章-物联网应用层通信协议" class="headerlink" title="第八章:物联网应用层通信协议"></a>第八章:物联网应用层通信协议</h3><h4 id="关长连接和短连接的区别"><a href="#关长连接和短连接的区别" class="headerlink" title="关长连接和短连接的区别"></a>关长连接和短连接的区别</h4><p><strong>长连接</strong>，和服务器的通信始终保持，就像打电话中的始终占线。服务端能保持的通信数量有限，达到通信数量的限制时就要增加服务器。一般用Socket或WebSocket开发长链接，在手游和聊天推送服务中有较多的应用。</p><p><strong>短连接</strong>，和服务端的通信在需要时才连接，是主流的通信方式，开发效率高。比如HTTP协议。</p><h4 id="并发连接访问中的C10K问题"><a href="#并发连接访问中的C10K问题" class="headerlink" title="并发连接访问中的C10K问题"></a>并发连接访问中的C10K问题</h4><p>当并发连接超过<strong>10000</strong>以上时使用<strong>传统的单机服务</strong>技术会引发<strong>宕机</strong>。比如在Web内存服务中，每个连接都会生成一个新线程，每个新线程可能需要2MB的内存，那么8G内存的主机，理论上最大的并发连接数量是4000。</p><h4 id="通信数据格式"><a href="#通信数据格式" class="headerlink" title="通信数据格式"></a>通信数据格式</h4><p>通用主要有两种数据格式<strong>（1）XML（2）JSON</strong></p><h4 id="物联网协议XMPP"><a href="#物联网协议XMPP" class="headerlink" title="物联网协议XMPP"></a><strong>物联网协议XMPP</strong></h4><p>XMPP（Extensible Messageing and Presence Protocol：可扩展消息与存在协议）是目前主流的四种IM（IM：instant messaging,即时消息）协议之一，其他三种分别为：即时信息和空间协议(IMPP)、空间和即时信息协议(PRIM)、针对即时通讯和空间平衡扩充的进程开始协议SIP(SIMPLE)。</p><p><strong>XMPP 的消息格式</strong></p><p>XMPP 协议的所有消息都是 <strong>XML 格式</strong>的。XMPP 通过 TCP 传输，它用于即时消息（IM）以及在线现场探测。XMPP允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。</p><p><strong>XMPP内容</strong></p><p>XMPP定义了3个角色客户端(Client)、服务器(Server)、网关(Gateway)。通信能够在这三者的任意两个之间双向发生。</p><p>  （1）服务器同时承担了客户端信息记录、连接管理和信息的路由功能 。</p><p>  （2）网关承担着与异构即时通信系统的 互联互通，异构系统可以包括SMS （短信），MSN，ICQ等。</p><p>  （3）客户端利用XMPP（基于TCP/IP）访 问server，传输的是XML。</p><p><strong>XMPP 的交互流程如下：</strong></p><p>•所有从一个 client 到另一个 client 的消息和数据都要经过 XMPP Server；</p><p>•client1 连接到Server；</p><p>•server 利用本地目录系统的证书对其认证；</p><p>•client1 指定 client2 目标地址，让 server 告知 client2 目标状态；</p><p>•server 查找，连接并进行互相认证；</p><p>•client1 和 client2 进行交互。</p><h4 id="物联网协议RESTful-HTTP"><a href="#物联网协议RESTful-HTTP" class="headerlink" title="物联网协议RESTful HTTP"></a>物联网协议RESTful HTTP</h4><p>REST（Representational State Transfer，表现层状态转移） 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</p><p>Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。</p><p><strong>RESTful 架构特点</strong></p><p>o（1）每个URI代表一种资源。</p><p>o（2）客户端和服务端之间，传递这种资源的某种表现层。</p><p>o（3）客户端通过四个HTTP动作指令，对服务器端资源进行操作。</p><p>  GET:用来获取资源； POST:用来新建资源（也可用于更新资源）；PUT:用来更新资源； DELETE:用来删除资源。</p><h4 id="HTTP原理"><a href="#HTTP原理" class="headerlink" title="HTTP原理"></a>HTTP原理</h4><p><strong>HTTP</strong>的全称是HyperText Transfer Protocol，<strong>超文本传输协议</strong>，这个协议的提出就是为了<strong>提供和接收HTML界面</strong>，通过这个协议在互联网上面传出web的界面信息。HTTP协议共有两个过程：Request和Response，两个都有各自的语言格式。<strong>HTTP协议命令</strong>主要是常用的<strong>GET和POST方法</strong>，<strong>GET就是获取什么内容，而POST就是向服务器发送什么数据</strong>。当然还有其他的，比如HTTP 1.1中还有：DELETE、PUT、CONNECT、HEAD、OPTIONS、TRACE等一共8个方法（HTTP Method历史：HTTP 0.9 只有GET方法；HTTP 1.0 有GET、POST、HEAD三个方法）。</p><h4 id="传统Web的问题"><a href="#传统Web的问题" class="headerlink" title="传统Web的问题"></a>传统Web的问题</h4><p>1.系统之间缺乏良好的互操作性。2.系统内部耦合度较强，应用模式不够灵活</p><h4 id="Web服务与Web服务器的区别"><a href="#Web服务与Web服务器的区别" class="headerlink" title="Web服务与Web服务器的区别"></a>Web服务与Web服务器的区别</h4><p><strong>我们可以把WebService看作是Web服务器上应用；反过来说，Web服务器是WebService运行时所必需的容器。这就是它们的区别和联系。</strong></p><h4 id="Web网页与Web服务"><a href="#Web网页与Web服务" class="headerlink" title="Web网页与Web服务"></a>Web网页与Web服务</h4><p>网页是供人理解和阅读的，主要是HTML格式，包含内容和样式等。</p><p>Web服务是一种基于Web的编程组件，供客户计算机程序来调用的。其结果主要采用XML和JSON等计算机能够自动理解的格式，而不是供人直接阅读。</p><h4 id="物联网协议MQTT（重点）"><a href="#物联网协议MQTT（重点）" class="headerlink" title="物联网协议MQTT（重点）"></a>物联网协议MQTT（重点）</h4><p><strong>MQTT协议基于发布/订阅（Publish/Subscribe）模式</strong></p><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则： </p><p>（1）精简，不添加可有可无的功能。（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递。（3）允许用户动态创建主题，零运维成本。（4）把传输量降到最低以提高传输效率。（5）把低带宽、高延迟、不稳定的网络等因素考虑在内。（6）支持连续的会话控制。（7）理解客户端计算能力可能很低。（8）提供服务质量管理。（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</p><p><strong>发布者</strong>与<strong>订阅者</strong>不比了解彼此，只要认识同一个<strong>消息代理</strong>即可。发布者和订阅者不需要交互，发布者无需等待订阅者确认而导致锁定。发布者和订阅者不需要同时在线，可以自由选择时间来消费消息<br><img src="https://img-blog.csdnimg.cn/6f6bf97999e04a22a5b9187cda2efae2.png" alt="在这里插入图片描述"></p><p>MQTT是通过<strong>主题</strong>对<strong>消息进行分类</strong>的，本质上就是一个UTF-8的字符串，不过可以通过反斜杠表示多个层级关系。主题并不需要创建，直接使用就是了。</p><p><strong>服务质量</strong></p><p>为了满足不同的场景，MQTT支持三种不同级别的服务质量（Quality of Service，QoS）为不同场景提供消息可靠性：</p><p>级别0：尽力而为。消息发送者会想尽办法发送消息，但是遇到意外并不会重试。</p><p>级别1：至少一次。消息接收者如果没有知会或者知会本身丢失，消息发送者会再次发送以保证消息接收者至少会收到一次，当然可能造成重复消息。</p><p>级别2：恰好一次。保证这种语义肯待会减少并发或者增加延时，不过丢失或者重复消息是不可接受的时候，级别2是最合适的。</p><p>服务质量是个老话题了。级别2所提供的不重不丢很多情况下是最理想的，不过往返多次的确认一定对并发和延迟带来影响。级别1提供的至少一次语义在日志处理这种场景下是完全OK的，所以像Kafka这类的系统利用这一特点减少确认从而大大提高了并发。级别0适合鸡肋数据场景，食之无味弃之可惜。</p><h4 id="物联网协议CoAP"><a href="#物联网协议CoAP" class="headerlink" title="物联网协议CoAP"></a>物联网协议CoAP</h4><p>CoAP是受限制的应用协议(Constrained Application Protocol)的代名词。在最近几年的时间中，专家们预测会有更多的设备相互连接，而这些<strong>设备的数量将远超人类的数量</strong>。在这种大背景下，物联网和M2M技术应运而生。虽然对人而言，连接入互联网显得方便容易，但是对于那些微型设备而言接入互联网非常困难。在当前由PC机组成的世界，信息交换是通过TCP和应用层协议HTTP实现的。但是对于小型设备而言，实现TCP和HTTP协议显然是一个过分的要求。<strong>为了让小设备可以接入互联网</strong>，<strong>CoAP协议</strong>被设计出来。CoAP是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。CoAP协议非常的小巧，<strong>最小的数据包</strong>仅为4字节。CoAP适用于低功耗受限设备，一个内存为20KB的单片机就可以实现CoAP服务器或客户端。</p><h4 id="CoAP与MQTT的区别"><a href="#CoAP与MQTT的区别" class="headerlink" title="CoAP与MQTT的区别"></a>CoAP与MQTT的区别</h4><p>MQTT和CoAP都是行之有效的物联网协议，但两者还是有很大区别的，比如MQTT协议是基于TCP，而CoAP协议是基于UDP。从应用方向来分析，主要区别有以下几点：</p><p>MQTT协议不支持带有类型或者其它帮助Clients理解的标签信息，也就是说所有MQTT Clients必须要知道消息格式。而CoAP协议则相反，因为CoAP内置发现支持和内容协商，这样便能允许设备相互窥测以找到数据交换的方式。</p><p>MQTT是<strong>长连接</strong>而CoAP是<strong>无连接</strong>。MQTT Clients与Broker之间保持<strong>TCP长连接</strong>，这种情形在NAT环境中也不会产生问题。如果在NAT环境下使用CoAP的话，那就需要采取一些NAT穿透性手段。</p><p>MQTT是多个客户端通过中央代理进行消息传递的<strong>多对多协议</strong>。它主要通过让<strong>客户端发布消息</strong>、<strong>代理决定消息路由</strong>和复制来解耦消费者和生产者。MQTT就是相当于<strong>消息传递的实时通讯总线</strong>。CoAP基本上就是一个在Server和Client之间传递状态信息的<strong>单对单协议</strong>。</p><h3 id="第九章-低功耗广域网通信"><a href="#第九章-低功耗广域网通信" class="headerlink" title="第九章:低功耗广域网通信"></a>第九章:低功耗广域网通信</h3><h4 id="LPWAN概念及特点"><a href="#LPWAN概念及特点" class="headerlink" title="LPWAN概念及特点"></a>LPWAN概念及特点</h4><p>低功耗广域网（Low Power Wide Area Network，LPWAN）是为了因应物联网（Internet of Things，IoT）远距离通讯需求而产生的技术，具有高覆盖、低功耗和广域连接等特性。</p><p>在LPWAN出现以前，已存在多种通信技术，<strong>短距离的有WiFi、蓝牙、Zigbee等，长距离的则有2G、3G、4G等</strong>，但是如果把这些无线通信技术按照功耗与传输距离这两个维度分来的话，可以发现在<strong>功耗低、距离远这个范围的技术还有所欠缺</strong>，而<strong>LPWAN技术的出现正好弥补了这个短板。</strong></p><p>低功耗广域网（LPWAN）是一种远距离低功耗的无线通信网络。多数 LPWA 技术可以实现几公里甚至几十公里的网络覆盖。由于其网络覆盖范围广、终端功耗低等特点其更适合于大规模的物联网应用部署。</p><p><strong>LPWAN拥有以下主要特点：</strong>(1)低功耗：电池寿命可长达 10 年 (2)远距离：覆盖范围广，可达几十公里，在城市环境中的工作范围通常也超过2km (3)低数据速率：占用带宽小，传输的数据量少，通信频次低 (4)传输时延不敏感：对数据传输实时性要求不高 (5)低成本：由于规模大要求部署的成本低。</p><p><strong>LPWAN适用于长距离传输少量数据，同时电池寿命能够维持多年的应用场景</strong>。这是LPWAN与蓝牙、RFID、蜂窝M2M和ZigBee等其他无线网络协议的主要区分。</p><h4 id="LPWAN的应用"><a href="#LPWAN的应用" class="headerlink" title="LPWAN的应用"></a>LPWAN的应用</h4><p>LPWAN应用分成了五类：智慧工业（Smart Industry）、智慧公共事业（Smart Utilities）、智慧城市（Smart Cities）、智慧建筑（Smart Buildings）及其他应用（Other applications）。</p><h4 id="蜂窝LPWA技术"><a href="#蜂窝LPWA技术" class="headerlink" title="蜂窝LPWA技术"></a>蜂窝LPWA技术</h4><p><strong>NB-IoT</strong> - 即Cat-NB1，Narrowband IoT，窄带物联网。新增到LTE平台的无线电规范，针对低端市场而优化。</p><p><strong>eMTC</strong> - 即Cat M1，Long-Term Evolution Enhanced Machine Type Communications, 长期演进增强机器类通信。基于Release 12规范的改进（UE Cat0, 新的省电模式：PSM），针对机器类型通信的进一步LTE增强功能</p><p><strong>EC-GSM-IoT - Extended Coverage GSM for Internet of Thing</strong>s, 扩展覆盖范围GSM物联网。EC-GSM-IoT建立在GPRS/EGPRS基础之上，EGPRS的增强功能并与PSM相结合，使得GSM/EDGE可以面向物联网市场。</p><h3 id="第十章-物联网云平台"><a href="#第十章-物联网云平台" class="headerlink" title="第十章:物联网云平台"></a>第十章:物联网云平台</h3><p>物联网云平台是把物联网和云计算技术堆栈融合在一起的平台，一般支持物联网智能终端汇聚、应用开发运行服务和轻量级应用提供的云平台，旨在降低物联网应用开发的准入门槛，降低智能硬件的接入门槛，提供端到端的解决方案，服务于终端开发者、能力提供商、应用开发商等。</p><p><strong>物联网是将整个物理世界的数据进行采集和传输</strong>，从而达到智慧化。而<strong>物联网云平台正是向下接入分散的物联网传感层</strong>，汇集传感数据；<strong>向上则是集成物联网行业各种应用</strong>。</p><p><strong>物联网云平台的主要功能如下：</strong></p><p><strong>(1)可扩展性</strong>：物联网云平台一般支持大量同步设备连接，能够监控设备性能并支持进行扩展。支持T-link、MQTT、LWM2M等多种协议的设备接入，既满足长连接的实时性需求，也满足短连接的低功耗需求。</p><p><strong>(2)设备管理功能</strong></p><p>•云计算API - 能够更好地管理设备，对大量设备进行细分以实现更精细的控制，并实时监控设备的运行状况。</p><p>•开发人员工具 - 一个核心界面或一组工具，允许组织以无线方式管理和重新编程其物联网设备。</p><p>•设备命令和控制 - 基于云计算的功能，允许用户通过其Rest API结构控制变量和事件。</p><p>•事件日志 -允许组织实时查看设备发生情况的界面，以改善查找与其相关的数据的体验。</p><p>•远程诊断 - 允许组织主动监视设备运行状况的功能，并在出现警告标志时采取先发制人的行动。</p><p><strong>(3)无线固件更新</strong></p><p>  无线(OTA)固件更新是任何物联网云平台的重要组成部分。无线固件是指远程更新嵌入式设备上的代码的做法。</p><p><strong>(4)数据管理</strong></p><p>主要对设备上报的数据按照用户设定的规则进行数据加工和数据清洗。应用根据加工或清洗后的数据做出相应的动作，比如：数据推送提醒，告警提醒等。</p><p><strong>(5)安全性。保障设备、信息安全。</strong></p><p>硬件密钥 - 每个设备都应有自己的私钥，因此未经授权的设备不能应用在组织中。</p><p>双因素身份验证 - 在物联网方面，组织总是需要额外的安全性。在其可以访问设备之前，通过添加第二个步骤来保护其帐户，在可以访问自己设备之前验证身份。</p><p>基于角色的访问控制 - 对于大型公司来说，需要一个物联网云平台，允许其控制谁可以管理和读取其设备上的数据。</p><p>没有开放端口 - 所有远程设备都不应为端口扫描程序或主动端攻击保留打开的传入端口</p><p><strong>接入协议</strong></p><p><strong>(1)LwM2M 轻量级机器到机器 （Lightweight Machine-To-Machine）应用层协议</strong></p><p>协议基于REST架构。协议的消息传递是通过CoAP协议来达成的。协议定义了一个紧凑高效又不乏扩展性的数据模型。协议最主要的实体包括LwM2M Server和LwM2M Client。LwM2M Serve作为服务器，部署在M2M服务供应商处或网络服务供应商处。LwM2M Client作为客户端，部署在各个LwM2M设备上。</p><p><strong>设备侧适用特点</strong>：使用NB网络； 对于深度和广度覆盖要求高； 对成本和功耗十分敏感； 对数据传输的实时性要求不高； 存在海量连接，需要传输加密；周期性上报特点明显；</p><p><strong>平台侧提供功能</strong>： 存储设备上报的资源列表及数据； 下发数据及命令至设备；接收海量大并发的数据传输和存储；数据推送到应用；</p><p><strong>典型适用行业：</strong>水、电、气、暖等智能表具；智能井盖等市政场景。</p><p><strong>(2)MQTT协议接入</strong></p><p><strong>设备侧适用特点</strong>：需要设备上报数据到平台；需要实时接收控制指令；有充足的电量支持设备保持在线；需要保持长连接状态；</p><p><strong>平台侧提供功能</strong>：存储设备上报的数据点；下发应用实时、离线自定义数据或命令；下发固件更新地址通知；提供数据推送到应用；基于topic的消息订阅/发布。</p><p><strong>典型适用行业：</strong>可灵活适用于多种场景 </p><p><strong>(3)TCP透传</strong></p><p>TCP面向连接（如打电话要先拨号建立连接）。提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。传输效率相对较低。连接只能是点到点、一对一的。</p><p><strong>设备侧适用特点</strong>：保持长连接；双向通信；用户自定义通信数据格式；</p><p><strong>平台侧提供功能</strong>：支持上传自定义的脚本解析自定义数据；存储设备上报的数据点；支持自定义命令下发；支持数据推送到应用； </p><p><strong>典型适用行业</strong>：用户自定义数据协议；简单控制类场景如共享单车。</p><p><strong>（4）HTTP</strong></p><p><strong>设备侧适用特点：</strong>只上报传感器数据到平台；无需下行控制指令到设备；</p><p><strong>平台侧提供功能：</strong>存储设备上报的数据点；提供API接口实现设备管理；提供数据推送到应用；</p><p><strong>典型适用行业：</strong>简单数据上报场景</p><p><strong>（5）omodbus协议接入</strong></p><p><strong>设备侧适用特点：</strong>设备类型主要是基于TCP的DTU；DTU下挂设备为标准modbus协议通信设备</p><p><strong>平台侧提供功能：</strong>自定义配置采集命令以及采集周期；存储设备上报的数据点；下发自定义modbus命令；数据推送到应用。</p><p><strong>典型适用行业</strong>：使用Modbus+DTU进行数据采集的行业</p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>物联网感知识别设备</strong>：对应一些物联网终端感知识别设备，比如温湿度传感器节点。</p><p><strong>物联网网关</strong>：物联网感知识别终端设备一般通过短距离无线通信技术接入互联网，这里一般需要一个转接设备，就是物联网网关。</p><p><strong>物联网云平台</strong>：物联网服务端平台，一般提供物联网数据的存储、处理和展示，还提供物联网终端设备管理等功能。</p><p><strong>用户端</strong>：基于物联网服务端平台提供的功能，面向用户的应用程序，可以是手机应用程序、桌面应用程序、Web应用程序等。</p><h3 id="实验一：基于Arduino和App-Inventor的温湿度监视器"><a href="#实验一：基于Arduino和App-Inventor的温湿度监视器" class="headerlink" title="实验一：基于Arduino和App Inventor的温湿度监视器"></a>实验一：基于Arduino和App Inventor的温湿度监视器</h3><p>实验一构建了一个很简单的物联网系统，从结构上来看它包含了物联网的感知层，拥有温度传感器设备，也有基于App inventor开发的应用层的程序。二者通过近距离无线通信技术<strong>蓝牙</strong>进行交互。感知层温度传感器获取当前温湿度信息，下位机将获取到的<strong>温湿度数据</strong>通过<strong>串口</strong>发送给<strong>蓝牙模块</strong>，之后蓝牙模块转发到上位机（应用层的手机），最终实现实时检测环境温度功能。<del>这个实验较为简单，感觉重要的应该是下面的一个实验</del></p><h3 id="实验二：简单物联网网关及物联网系统构建"><a href="#实验二：简单物联网网关及物联网系统构建" class="headerlink" title="实验二：简单物联网网关及物联网系统构建"></a>实验二：简单物联网网关及物联网系统构建</h3><p>实验二构建了一个较为完善的物联网系统，体现物联网的基本体系结构，从结构上来看它包含了物联网的感知层，拥有温度传感器设备，有智能手机充当的物联网网关作为网络层，还有在服务器上搭建的MQTT协议的物联网云平台作为应用层。整个体系结构较为完整。</p><p>由于下位机不具备联网功能，我们需要通过在智能手机安装<strong>基于MQTT协议的APP</strong>让智能手机充当物联网网关。首先是下位机读取到温湿度传感器的数据，通过近距离无线通信技术<strong>蓝牙</strong>进行交互将获取到的<strong>温湿度数据</strong>通过<strong>串口</strong>发送给<strong>蓝牙模块</strong>，之后蓝牙模块转发到智能手机上，然后智能手机通过MQTT客户端向指定的话题发送数据。电脑端也充当一个客户端，连接到阿里云上面的服务器，之后订阅手机端发送数据的话题，就能实现手机将测得的温湿度发送到云端服务器，云端服务器将向订阅该话题的客户端发送温湿度数据，最后完成实验。</p><p>通过此次实验，基于重要通信协议MQTT协议，它的订阅发布模式是一种一对多的消息分发机制，不同于点对点的协议，消息不是直接从发送器发送到接收器（即点对点），而是由MQTT server（或称为 MQTT Broker）分发的。这次实验也是让我们搭建了一个简单的物联网系统。由于Arduino没有接入互联网，所以我们通过手机接收数据，手机同服务器进行连接，手机起到了一个网关的作用。让整个体系结构以下就明了起来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于node.js搭建简单的MQTT服务器，手机通过热点连接电脑实现MQTT服务器测试</title>
    <link href="/2021/12/25/%E5%9F%BA%E4%BA%8Enode.js%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%89%8B%E6%9C%BA%E9%80%9A%E8%BF%87%E7%83%AD%E7%82%B9%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%E5%AE%9E%E7%8E%B0MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/12/25/%E5%9F%BA%E4%BA%8Enode.js%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%89%8B%E6%9C%BA%E9%80%9A%E8%BF%87%E7%83%AD%E7%82%B9%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%E5%AE%9E%E7%8E%B0MQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="基于node-js搭建简单的MQTT服务器，手机通过热点连接电脑实现MQTT服务器测试"><a href="#基于node-js搭建简单的MQTT服务器，手机通过热点连接电脑实现MQTT服务器测试" class="headerlink" title="基于node.js搭建简单的MQTT服务器，手机通过热点连接电脑实现MQTT服务器测试"></a>基于node.js搭建简单的MQTT服务器，手机通过热点连接电脑实现MQTT服务器测试</h1><h2 id="服务器搭建"><a href="#服务器搭建" class="headerlink" title="服务器搭建"></a>服务器搭建</h2><p>首先搭建好node.js环境，配置好<strong>MQTT</strong>服务器，这个网上教程有许多，可以参照这篇博客来进行配置。</p><p>服务端mqtt.js:</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> mosca = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mosca&quot;</span>);<br><span class="hljs-keyword">const</span> MqttServer = <span class="hljs-keyword">new</span> mosca.Server(&#123;<br>  <span class="hljs-attribute">port</span>: <span class="hljs-number">1883</span><br>&#125;);<br>MqttServer.on(<span class="hljs-string">&quot;clientConnected&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">client</span>) </span>&#123;<br>  <span class="hljs-comment">//当有客户端连接时的回调.</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;client connected&quot;</span>, client.id);<br>&#125;);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 监听MQTT主题消息</span><br><span class="hljs-comment"> * 当客户端有连接发布主题消息时</span><br><span class="hljs-comment"> **/</span><br>MqttServer.on(<span class="hljs-string">&quot;published&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">packet, client</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> topic = packet.topic;<br>  <span class="hljs-keyword">switch</span> (topic) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;test&quot;</span>:<br>      <span class="hljs-comment">// console.log(&#x27;message-publish&#x27;, packet.payload.toString());</span><br>      <span class="hljs-comment">//MQTT可以转发主题消息至其他主题</span><br>      <span class="hljs-comment">//MqttServer.publish(&#123; topic: &#x27;other&#x27;, payload: &#x27;sssss&#x27; &#125;);</span><br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;other&quot;</span>:<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;message-123&quot;</span>, packet.payload.toString());<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;);<br><br>MqttServer.on(<span class="hljs-string">&quot;ready&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//当服务开启时的回调</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;mqtt is running...&quot;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>客户端发送方publish.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mqtt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mqtt&quot;</span>);<br><span class="hljs-keyword">const</span> client = mqtt.connect(<span class="hljs-string">&quot;mqtt://192.168.137.1 :1883&quot;</span>); <span class="hljs-comment">//连接到mqtt服务端</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> value = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">40</span>);<br>  client.publish(<span class="hljs-string">&quot;test&quot;</span>, value.toString(), &#123; <span class="hljs-attr">qos</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">retain</span>: <span class="hljs-literal">true</span> &#125;);<br>&#125;, <span class="hljs-number">3000</span>);<br><br></code></pre></td></tr></table></figure><p>客户端订阅方subscribe.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mqtt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mqtt&quot;</span>);<br><span class="hljs-comment">// const mqtt = require(&#x27;./node_modules/mqtt/dist/mqtt.min.js&#x27;)</span><br><span class="hljs-keyword">const</span> client = mqtt.connect(<span class="hljs-string">&quot;mqtt://192.168.137.1 :1883&quot;</span>); <span class="hljs-comment">//指定服务端地址和端口</span><br>client.on(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务器连接成功&quot;</span>);<br>  <span class="hljs-comment">// connected = client.connected</span><br>  client.subscribe(<span class="hljs-string">&quot;test&quot;</span>, &#123; <span class="hljs-attr">qos</span>: <span class="hljs-number">0</span>&#125;); <span class="hljs-comment">//订阅主题为test的消息</span><br>&#125;);<br>client.on(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">top, message</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;当前topic：&quot;</span>, top);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;收到消息：&quot;</span>, message.toString());<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先终端输入node mqtt打开服务端</p><p><img src="/C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20211225125204773.png" alt="image-20211225125204773"></p><p>输入node subscribe打开接收客户端</p><p>输入node publish 打开发送客户端</p><p>之后可以看到</p><p><img src="/C:/Users/zhang/Desktop/C%5BB9H4L%7BZU@%60G9PT3%5DS3U85.png" alt="C[B9H4L{ZU@`G9PT3]S3U85"></p><p>发送客户端向test话题发送数据，接收客户端订阅test话题，能收到数据。证明MQTT服务器搭建完成。</p><h2 id="手机电脑MQTT测试"><a href="#手机电脑MQTT测试" class="headerlink" title="手机电脑MQTT测试"></a>手机电脑MQTT测试</h2><p>手机通过连接电脑热点进行手机发送客户端发送数据，电脑接收客户端订阅话题获取数据。</p><p>首先编写手机端APP，让它能使用MQTT协议发送数据，这里基于APP inventor开发了一个简单的APP来进行测试</p><p><img src="/C:/Users/zhang/Desktop/ui.png" alt="PW@D~WFZMMDSW2V6B~FQAN7"></p><p>逻辑设计：</p><p><img src="/C:/Users/zhang/Desktop/lj.png" alt="_{5%4CPYG9BQ92SRO~%16GF"></p><p>之后进行电脑端的配置，打开防火墙设置，把1883端口打开。</p><p><img src="/C:/Users/zhang/Desktop/fhq%E3%80%81.PNG" alt="fhq、"></p><p>之后打开电脑热点，手机连接到电脑热点</p><p><img src="/C:/Users/zhang/Desktop/Inkedrd_LI.jpg" alt="Inkedrd_LI"></p><p>然后查看自己电脑的ip地址</p><p><img src="/C:/Users/zhang/Desktop/ip.PNG" alt="ip"></p><p><strong>由于我的ip地址是上述，使用上面客户端配置的时候连接的服务端IP也是这个，自己配置的时候需要注意</strong></p><p>之后通过连接到服务器，电脑端打开接收客户端，手机端点击发送数据按钮，观察电脑接收客户端变化</p><p><img src="/C:/Users/zhang/Desktop/%E5%AE%9E%E9%AA%8C.PNG" alt="实验"></p><p>可以看到电脑端订阅到了手机客户端向服务器发送的数据。测试成功。</p><p>整个过程中我认为最重要的就说确定好自己的局域网连接情况，因为这是自己搭建的服务器，只有当手机和电脑在同一个局域网下，手机才能连接到电脑的服务端上面，否则是连接不上的，这是我做这次测试过程中最直观的感受。</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基基于阿里云服务器在Ubuntu环境下配置MQTT云服务平台</title>
    <link href="/2021/12/24/%E5%9F%BA%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEMQTT%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/"/>
    <url>/2021/12/24/%E5%9F%BA%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEMQTT%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基于阿里云服务器在Ubuntu环境下配置MQTT云服务平台"><a href="#基于阿里云服务器在Ubuntu环境下配置MQTT云服务平台" class="headerlink" title="基于阿里云服务器在Ubuntu环境下配置MQTT云服务平台"></a>基于阿里云服务器在Ubuntu环境下配置MQTT云服务平台</h1><p>首先登陆阿里云服务器</p><p><strong>1.安装所需要的依赖包</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$ sudo apt update &amp;&amp; sudo apt install -y <span class="hljs-string">\</span><br>    apt-transport-https <span class="hljs-string">\</span><br>    ca-certificates <span class="hljs-string">\</span><br>    curl <span class="hljs-string">\</span><br>    gnupg-agent <span class="hljs-string">\</span><br>    software-properties-common<br></code></pre></td></tr></table></figure><p><strong>2.添加 EMQ X 的官方 GPG 密钥</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -fsSL https:<span class="hljs-regexp">//</span>repos.emqx.io/gpg.pub | sudo apt-key add -<br></code></pre></td></tr></table></figure><p><strong>验证密钥</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ sudo apt-key fingerprint <span class="hljs-number">3E640D53</span><br><br>pub   rsa<span class="hljs-number">2048 2019</span>-<span class="hljs-number">04</span>-<span class="hljs-number">10</span> [SC]<br>    FC84 <span class="hljs-number">1</span>BA6 <span class="hljs-number">3775</span> <span class="hljs-number">5</span>CA8 <span class="hljs-number">487</span>B  <span class="hljs-number">1</span>E3C C<span class="hljs-number">0B4 0946</span> <span class="hljs-number">3E64 0D53</span><br>uid           [ unknown] emqx team &lt;support@emqx.io&gt;<br></code></pre></td></tr></table></figure><p><strong>3.使用以下命令设置 stable 存储库</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">$ sudo<span class="hljs-built_in"> add-apt-repository </span>\<br>    <span class="hljs-string">&quot;deb [arch=amd64] https://repos.emqx.io/emqx-ce/deb/ubuntu/ \</span><br><span class="hljs-string">    ./$(lsb_release -cs) \</span><br><span class="hljs-string">    stable&quot;</span><br></code></pre></td></tr></table></figure><p><strong>4.更新 apt 包索引</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo apt update<br></code></pre></td></tr></table></figure><p><strong>5.安装最新版本的 EMQ X Broker</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> empx<br></code></pre></td></tr></table></figure><p><strong>6.安装特定版本的 EMQ X Broker</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo apt-cache madison emqx<br><br>emqx |      <span class="hljs-number">4.0</span>.<span class="hljs-number">0</span> | https:<span class="hljs-regexp">//</span>repos.emqx.io<span class="hljs-regexp">/emqx-ce/</span>deb<span class="hljs-regexp">/ubuntu bionic/</span>stable amd64 Packages<br>emqx |      <span class="hljs-number">3.0</span>.<span class="hljs-number">1</span> | https:<span class="hljs-regexp">//</span>repos.emqx.io<span class="hljs-regexp">/emqx-ce/</span>deb<span class="hljs-regexp">/ubuntu bionic/</span>stable amd64 Packages<br>emqx |      <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span> | https:<span class="hljs-regexp">//</span>repos.emqx.io<span class="hljs-regexp">/emqx-ce/</span>deb<span class="hljs-regexp">/ubuntu bionic/</span>stable amd64 Packages<br>$ sudo apt install emqx=<span class="hljs-number">4.0</span>.<span class="hljs-number">0</span> <span class="hljs-comment">#更改4.0.0选择自己需要的版本</span><br></code></pre></td></tr></table></figure><p><strong>启动EMQ X Broker</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ emqx <span class="hljs-literal">start</span><br>emqx <span class="hljs-number">4.0</span>.<span class="hljs-number">0</span> is <span class="hljs-literal">started</span> successfully!<br><br>$ emqx_ctl status<br><span class="hljs-keyword">Node</span> <span class="hljs-title">&#x27;emqx</span>@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>&#x27; is <span class="hljs-literal">started</span><br>emqx v4.<span class="hljs-number">0.0</span> is running<br>停止 EMQ X Broker<br>$ emqx <span class="hljs-literal">stop</span><br>ok<br>卸载 EMQ X Broker<br>$ sudo apt remove emqx<br></code></pre></td></tr></table></figure><h2 id="阿里云服务器安全配置"><a href="#阿里云服务器安全配置" class="headerlink" title="阿里云服务器安全配置"></a>阿里云服务器安全配置</h2><p>进入安全配置打开这几个端口</p><p><img src="../img/%E5%9F%BA%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEMQTT%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/duankou.png" alt="duankou">然后就可以通过浏览器访问啦，找到你的阿里云服务器公网ip地址，在浏览器中输入<strong>yourip:18083</strong>,就会进入如下界面</p><p><img src="../img/%E5%9F%BA%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEMQTT%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/%E6%8D%95%E8%8E%B7.PNG" alt="捕获"><img src="../img/%E5%9F%BA%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEMQTT%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8.PNG%E8%B4%A6%E5%8F%B7%E4%B8%BA!%5B%E6%8D%95%E8%8E%B71%5D(../img/%E5%9F%BA%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEMQTT%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/%E6%8D%95%E8%8E%B71.PNG" alt="服务器">admin，密码为public</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EDA复习</title>
    <link href="/2021/12/10/EDA%E5%A4%8D%E4%B9%A0/"/>
    <url>/2021/12/10/EDA%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="EDA复习"><a href="#EDA复习" class="headerlink" title="EDA复习"></a>EDA复习</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>BIT和STD_LOGIC区别</strong></p><p><strong>TYPE BIT IS(‘0’,’1’)</strong> 只有两种取值，而 <strong>TYPE STD_LOGIC IS (‘U’,’X’,’0’,’1’,’Z’,’W’,’L’,’H’,’-‘)</strong>; –有9种取值</p><p><img src="C:/Users/zhang/AppData/Roaming/Typora/typora-user-images/image-20211209165313117.png" alt="image-20211209165313117"></p><h2 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h2><p>**信号赋值语句 &lt;= 变量赋值语句 := ** </p><p><strong>CASE语句</strong></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">CASE</span> &lt;表达式&gt; <span class="hljs-keyword">IS</span><br><span class="hljs-keyword">When</span> &lt;选择值或标识符&gt; =&gt; &lt;顺序语句&gt;; ... ; &lt;顺序语句&gt; ；<br><span class="hljs-keyword">When</span> &lt;选择值或标识符&gt; =&gt; &lt;顺序语句&gt;; ... ; &lt;顺序语句&gt; ；<br>...<br><span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">OTHERS</span> =&gt; &lt;顺序语句&gt;;<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span> ；<br>可选方式：<br>单个普通数值，如<span class="hljs-number">6</span>。<br>数值选择范围，如(<span class="hljs-number">2</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">4</span>)，表示取值为<span class="hljs-number">2</span>、<span class="hljs-number">3</span>或<span class="hljs-number">4</span>。<br>并列数值，如<span class="hljs-number">3</span><span class="hljs-number">5</span>，表示取值为<span class="hljs-number">3</span>或者<span class="hljs-number">5</span>。 <br>混合方式，以上三种方式的混合。   <br></code></pre></td></tr></table></figure><p><strong>PROCESS语句</strong></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">[进程标号: ] <span class="hljs-keyword">PROCESS</span> [ ( 敏感信号参数表  ) ] [<span class="hljs-keyword">IS</span>]<br>[进程说明部分]<br> <span class="hljs-keyword">BEGIN</span><br>     顺序描述语句<br> <span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCESS</span> [进程标号]; <br></code></pre></td></tr></table></figure><p><img src="../img/EDA%E5%A4%8D%E4%B9%A0/image-20211209170050919.png" alt="image-20211209170050919"></p><p><strong>IF语句</strong></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-keyword">IF</span>   条件句  <span class="hljs-keyword">Then</span> <br>   顺序语句 <br> <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span> ; <br> <br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">IF</span>  条件句 <span class="hljs-keyword">Then</span> <br>      顺序语句 <br><span class="hljs-keyword">ELSE</span>  <br>      顺序语句 <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span> ; <br><br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-keyword">IF</span>  条件句 <span class="hljs-keyword">Then</span><br>     顺序语句<br><span class="hljs-keyword">ELSIF</span>  条件句 <span class="hljs-keyword">Then</span><br>       顺序语句<br>      ...<br><span class="hljs-keyword">ELSE</span><br>     顺序语句<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span> <br><br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-keyword">IF</span>  条件句 <span class="hljs-keyword">Then</span> <br>       <span class="hljs-keyword">IF</span>  条件句 <span class="hljs-keyword">Then</span> <br>         ...  <br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span> <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span> <br></code></pre></td></tr></table></figure><p><strong>应用</strong></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-comment">--含异步复位和时钟使能的D触发器的VHDL描述 </span><br><br><span class="hljs-keyword">LIBRARY</span> IEEE ;<br><span class="hljs-keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span> ; <br><span class="hljs-keyword">ENTITY</span> DFF1 <span class="hljs-keyword">IS</span><br>  <span class="hljs-keyword">PORT</span> (CLK, RST, EN, D: <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span> ;<br>            Q : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span> );<br><span class="hljs-keyword">END</span> ;<br><span class="hljs-keyword">ARCHITECTURE</span> bhv <span class="hljs-keyword">OF</span> DFF1 <span class="hljs-keyword">IS</span><br>  <span class="hljs-keyword">SIGNAL</span> Q1 : <span class="hljs-built_in">STD_LOGIC</span>; <br><span class="hljs-keyword">BEGIN</span><br>   <span class="hljs-keyword">PROCESS</span> (CLK,Q1, RST, EN)<br>   <span class="hljs-keyword">BEGIN</span><br>     <span class="hljs-keyword">IF</span>  RST=‘<span class="hljs-number">1</span>’ <span class="hljs-keyword">THEN</span> Q1&lt;=‘<span class="hljs-number">0</span>’;<br>     <span class="hljs-keyword">ELSIF</span> CLK<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">AND</span> CLK = &#x27;<span class="hljs-number">1</span>‘ <span class="hljs-keyword">THEN</span><br>          <span class="hljs-keyword">IF</span> EN=‘<span class="hljs-number">1</span>’ <span class="hljs-keyword">THEN</span> Q1 &lt;= D; <br>          <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;    <br>     <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>; <br>   <span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCESS</span> ;<br>      Q &lt;= Q1 ;      <br><span class="hljs-keyword">END</span> bhv; <br><span class="hljs-comment">--说明：若将IF  RST=‘1’ THEN Q1&lt;=‘0’ 写在检测上升沿外面就是异步复位，若写在里面则是同步复位</span><br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-comment">--十进制同步使能异步复位加法计数器</span><br><span class="hljs-keyword">LIBRARY</span> IEEE ;<br><span class="hljs-keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span> ; <br><span class="hljs-keyword">ENTITY</span> CNT10 <span class="hljs-keyword">IS</span><br>    <span class="hljs-keyword">PORT</span> (CLK,RST,EN : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;                     <br>                  CQ : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC_VECTOR</span>(<span class="hljs-number">3</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>);     <br> COUT : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>  );           <br><span class="hljs-keyword">END</span> CNT10;<br><span class="hljs-keyword">ARCHITECTURE</span> behav <span class="hljs-keyword">OF</span> CNT10 <span class="hljs-keyword">IS</span><br><span class="hljs-keyword">BEGIN</span><br>   <span class="hljs-keyword">PROCESS</span>(CLK, RST, EN)<br>     <span class="hljs-keyword">VARIABLE</span>  CQI : <span class="hljs-built_in">STD_LOGIC_VECTOR</span>(<span class="hljs-number">3</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>); <br>   <span class="hljs-keyword">BEGIN</span><br>      <span class="hljs-keyword">IF</span> RST = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span>   CQI := (<span class="hljs-keyword">OTHERS</span> =&gt;<span class="hljs-string">&#x27;0&#x27;</span>) ; <br>       <span class="hljs-keyword">ELSIF</span> CLK<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">AND</span> CLK=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span><br>        <span class="hljs-keyword">IF</span> EN = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span>                        <br>          <span class="hljs-keyword">IF</span> CQI &lt; <span class="hljs-number">9</span> <span class="hljs-keyword">THEN</span>   CQI := CQI + <span class="hljs-number">1</span>; <br>           <span class="hljs-keyword">ELSE</span>    CQI := (<span class="hljs-keyword">OTHERS</span> =&gt;<span class="hljs-string">&#x27;0&#x27;</span>);            <br>          <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>        <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>      <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;   <br>       <span class="hljs-keyword">IF</span> CQI = <span class="hljs-number">9</span> <span class="hljs-keyword">THEN</span> COUT &lt;= <span class="hljs-string">&#x27;1&#x27;</span>; <br>       <span class="hljs-keyword">ELSE</span>    COUT &lt;= <span class="hljs-string">&#x27;0&#x27;</span>;<br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>         CQ &lt;= CQI; <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCESS</span>;<br><span class="hljs-keyword">END</span> behav; <br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-comment">--移位寄存器带有同步并行预置功能的8位右移移位寄存器。CLK是移位时钟信号，DIN是8位并行预置数据端口，LOAD是并行数据预置使能信号，QB是串行输出端口</span><br><span class="hljs-keyword">LIBRARY</span> IEEE;<br><span class="hljs-keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span>;<br><span class="hljs-keyword">ENTITY</span> SHFRT <span class="hljs-keyword">IS</span>                 <span class="hljs-comment">-- 8位右移寄存器</span><br>    <span class="hljs-keyword">PORT</span> (  CLK，LOAD : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;  <br>                    DIN : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC_VECTOR</span>(<span class="hljs-number">7</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>);<br>                     QB : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>  );<br><span class="hljs-keyword">END</span> SHFRT;<br><span class="hljs-keyword">ARCHITECTURE</span> behav <span class="hljs-keyword">OF</span> SHFRT <span class="hljs-keyword">IS</span><br>    <span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">PROCESS</span> (CLK, LOAD)<br>      <span class="hljs-keyword">VARIABLE</span> REG8 : <span class="hljs-built_in">STD_LOGIC_VECTOR</span>(<span class="hljs-number">7</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">BEGIN</span><br>         <span class="hljs-keyword">IF</span> CLK<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">AND</span> CLK = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span><br>            <span class="hljs-keyword">IF</span> LOAD = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span>  REG8 := DIN; <br>         <span class="hljs-keyword">ELSE</span>  REG8(<span class="hljs-number">6</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>) := REG8(<span class="hljs-number">7</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">1</span>); <br>         <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>         <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>         QB &lt;= REG8(<span class="hljs-number">0</span>); <span class="hljs-comment">-- 输出最低位</span><br>    <span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCESS</span>;         <br><span class="hljs-keyword">END</span> behav; <br><br></code></pre></td></tr></table></figure><p><strong>LOOP语句</strong></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">L2 : <span class="hljs-keyword">LOOP</span><br>              a := a+<span class="hljs-number">1</span>;<br>              <span class="hljs-keyword">EXIT</span> L2 <span class="hljs-keyword">WHEN</span> a &gt;<span class="hljs-number">10</span> ;             <span class="hljs-comment">-- 当a大于10时跳出循环</span><br>        <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span> L2;<br><br><br></code></pre></td></tr></table></figure><h2 id="并行语句"><a href="#并行语句" class="headerlink" title="并行语句"></a>并行语句</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-comment">--赋值语句</span><br><span class="hljs-keyword">ARCHITECTURE</span> curt <span class="hljs-keyword">OF</span> bc1 <span class="hljs-keyword">IS</span><br><span class="hljs-keyword">SIGNAL</span> s1, e, f, g, h : <span class="hljs-built_in">STD_LOGIC</span> ;<br><span class="hljs-keyword">BEGIN</span><br>    output1 &lt;= a <span class="hljs-keyword">AND</span> b ;<br>    output2 &lt;= c + d ;<br>    g &lt;= e <span class="hljs-keyword">OR</span> f ;<br>    h &lt;= e <span class="hljs-keyword">XOR</span> f ;<br>    s1 &lt;= g ;<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">ARCHITECTURE</span> curt； <br><span class="hljs-comment">--条件赋值语句</span><br><span class="hljs-keyword">ARCHITECTURE</span> behv <span class="hljs-keyword">OF</span> mux <span class="hljs-keyword">IS</span><br>  <span class="hljs-keyword">BEGIN</span><br>    z  &lt;= a <span class="hljs-keyword">WHEN</span> p1 = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">ELSE</span><br>           b <span class="hljs-keyword">WHEN</span> p2 = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">ELSE</span><br>           c  ;<br> <span class="hljs-keyword">END</span>; <br><span class="hljs-comment">--选择信号赋值语句</span><br><span class="hljs-keyword">WITH</span> 选择表达式 <span class="hljs-keyword">SELECT</span> <br>赋值目标信号 &lt;= 表达式 <span class="hljs-keyword">WHEN</span> 选择值   <br>              表达式 <span class="hljs-keyword">WHEN</span> 选择值<br>                   ...<br>               表达式 <span class="hljs-keyword">WHEN</span> 选择值； <br><br> instruction &lt;= c &amp; b &amp; a ;<br> <span class="hljs-keyword">WITH</span> instruction <span class="hljs-keyword">SELECT</span><br> dataout &lt;=    data1  <span class="hljs-keyword">AND</span> data2  <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;000&quot;</span> ，<br>               data1  <span class="hljs-keyword">OR</span>  data2  <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;001&quot;</span> ，<br>               data1 <span class="hljs-keyword">NAND</span> data2  <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;010&quot;</span> ，<br>               data1 <span class="hljs-keyword">NOR</span>  data2  <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;011&quot;</span> ，<br>               data1 <span class="hljs-keyword">XOR</span>  data2  <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;100&quot;</span> ，<br>               data1 <span class="hljs-keyword">XNOR</span> data2  <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;101&quot;</span> ，<br>                           <span class="hljs-string">&#x27;Z&#x27;</span>   <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">OTHERS</span> ; <br><span class="hljs-comment">-- 元件例化语句</span><br>    <br><span class="hljs-keyword">COMPONENT</span> 元件名 <span class="hljs-keyword">IS</span> <br>   <span class="hljs-keyword">GENERIC</span> (类属表)；              <span class="hljs-comment">-- 元件定义语句</span><br>   <span class="hljs-keyword">PORT</span>  (端口名表)；<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">COMPONENT</span> 文件名；<br>    <br>例化名 ：元件名 <span class="hljs-keyword">PORT</span> <span class="hljs-keyword">MAP</span>(           <span class="hljs-comment">-- 元件例化语句</span><br>         [端口名 =&gt;] 连接端口名，...) ； <br><br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-comment">--例：半加器例化全加器</span><br><span class="hljs-keyword">LIBRARY</span>  IEEE;   <span class="hljs-comment">--1位二进制全加器顶层设计描述</span><br> <span class="hljs-keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span>;<br> <span class="hljs-keyword">ENTITY</span> f_adder <span class="hljs-keyword">IS</span><br>   <span class="hljs-keyword">PORT</span> (ain，bin，cin  : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>              cout，sum   : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span> );<br> <span class="hljs-keyword">END</span> <span class="hljs-keyword">ENTITY</span> f_adder;<br> <span class="hljs-keyword">ARCHITECTURE</span> fd1 <span class="hljs-keyword">OF</span> f_adder <span class="hljs-keyword">IS</span><br>   <span class="hljs-keyword">COMPONENT</span> h_adder                   <span class="hljs-comment">--调用半加器声明语句</span><br>     <span class="hljs-keyword">PORT</span> (  a，b :  <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>       co，so :  <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>);<br>   <span class="hljs-keyword">END</span> <span class="hljs-keyword">COMPONENT</span> ；<br>   <span class="hljs-keyword">COMPONENT</span> or2a<br>      <span class="hljs-keyword">PORT</span> (a，b : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>; <br>                c : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>);<br>   <span class="hljs-keyword">END</span> <span class="hljs-keyword">COMPONENT</span>；<br><span class="hljs-keyword">SIGNAL</span> d，e，f  :  <span class="hljs-built_in">STD_LOGIC</span>; <span class="hljs-comment">--定义3个信号作为内部的连接线。</span><br>  <span class="hljs-keyword">BEGIN</span><br>   u1 : h_adder <span class="hljs-keyword">PORT</span> <span class="hljs-keyword">MAP</span>(a=&gt;ain，b=&gt;bin，co=&gt;d，so=&gt;e);  <span class="hljs-comment">--例化语句</span><br>   u2 : h_adder <span class="hljs-keyword">PORT</span> <span class="hljs-keyword">MAP</span>(e，  cin， f，sum);<br>   u3 :   or2a   <span class="hljs-keyword">PORT</span> <span class="hljs-keyword">MAP</span>(a=&gt;d，  b=&gt;f，   c=&gt;cout);<br> <span class="hljs-keyword">END</span> <span class="hljs-keyword">ARCHITECTURE</span> fd1; <br></code></pre></td></tr></table></figure><p><img src="../img/EDA%E5%A4%8D%E4%B9%A0/image-20211209201027090.png" alt="image-20211209201027090"></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">LIBRARY</span> IEEE;<br><span class="hljs-keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span>;<br><span class="hljs-keyword">ENTITY</span> CONTROL <span class="hljs-keyword">IS</span><br>  <span class="hljs-keyword">PORT</span> ( clk,reset    : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>          inputs : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC_VECTOR</span> (<span class="hljs-number">0</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">1</span>);<br>          red,green,yellow : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span> );<br><span class="hljs-keyword">END</span> CONTROL;<br><span class="hljs-keyword">ARCHITECTURE</span> behv <span class="hljs-keyword">OF</span> CONTROL <span class="hljs-keyword">IS</span><br> <span class="hljs-keyword">TYPE</span> FSM_ST <span class="hljs-keyword">IS</span> (s0, s1, s2);<span class="hljs-comment">--数据类型定义，状态符号化</span><br> <span class="hljs-keyword">SIGNAL</span> current_state, next_state: FSM_ST;<br><span class="hljs-keyword">BEGIN</span><br>REG: <span class="hljs-keyword">PROCESS</span> (reset,clk)                  <span class="hljs-comment">--主控时序进程</span><br>     <span class="hljs-keyword">BEGIN</span><br>      <span class="hljs-keyword">IF</span> reset = ‘<span class="hljs-number">1</span>’ <span class="hljs-keyword">THEN</span>   current_state &lt;= s0;<br>      <span class="hljs-keyword">ELSIF</span> clk=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">AND</span> clk<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">THEN</span>   <br>      current_state &lt;= next_state; <br>      <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>     <span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCESS</span>;<br>         <br>COM:<span class="hljs-keyword">PROCESS</span>(current_state, inputs)   <span class="hljs-comment">--主控组合进程</span><br>    <span class="hljs-keyword">BEGIN</span><br>     <span class="hljs-keyword">CASE</span> current_state <span class="hljs-keyword">IS</span>                     <br>      <span class="hljs-keyword">WHEN</span> s0 =&gt; red=<span class="hljs-string">&#x27;1&#x27;</span>;green=<span class="hljs-string">&#x27;0&#x27;</span>;yellow=<span class="hljs-string">&#x27;0&#x27;</span>;     <br>        <span class="hljs-keyword">IF</span> state_inputs = <span class="hljs-string">&quot;00&quot;</span> <span class="hljs-keyword">THEN</span>  next_state&lt;=s0;                    <br>           <span class="hljs-keyword">ELSE</span>  next_state&lt;=s1;    <br>        <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>      <span class="hljs-keyword">WHEN</span> s1 =&gt;  red=<span class="hljs-string">&#x27;0&#x27;</span>;green=<span class="hljs-string">&#x27;1&#x27;</span>;yellow=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">IF</span> state_inputs = <span class="hljs-string">&quot;01&quot;</span> <span class="hljs-keyword">THEN</span>  next_state&lt;=s1;    <br>        <span class="hljs-keyword">ELSE</span>  next_state&lt;=s2;   <br>        <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>      <span class="hljs-keyword">WHEN</span> s2 =&gt;   red=<span class="hljs-string">&#x27;0&#x27;</span>;green=<span class="hljs-string">&#x27;0&#x27;</span>;yellow=<span class="hljs-string">&#x27;1&#x27;</span>;  <br>        <span class="hljs-keyword">IF</span> state_inputs = <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-keyword">THEN</span>  next_state &lt;= s0;<br>        <span class="hljs-keyword">ELSE</span>  next_state &lt;= s3; <br>        <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>      <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">OTHERS</span> =&gt; next_state &lt;= s0;  <br>    <span class="hljs-keyword">END</span> <span class="hljs-keyword">case</span>;<br>   <span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCESS</span>;      <br> <span class="hljs-keyword">END</span> behv; <br><br></code></pre></td></tr></table></figure><p><img src="../img/EDA%E5%A4%8D%E4%B9%A0/image-20211209201808521.png" alt="image-20211209201808521"></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-comment">--八进制同步使能异步复位加法计数器</span><br><span class="hljs-keyword">LIBRARY</span> IEEE ;<br><span class="hljs-keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span> ; <br><span class="hljs-keyword">USE</span> IEEE.STD_LOGIC_UNSIGNED.<span class="hljs-keyword">ALL</span>; <span class="hljs-comment">--调用加法运算符时需要添加</span><br><span class="hljs-keyword">ENTITY</span> CNT8 <span class="hljs-keyword">IS</span><br>    <span class="hljs-keyword">PORT</span> (CLK,RST,EN,LOAD : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>; <br>          COUT : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>                  CQ : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC_VECTOR</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>);     <br> DATA : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC_VECTOR</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>));           <br><span class="hljs-keyword">END</span> CNT8;<br><span class="hljs-keyword">ARCHITECTURE</span> behav <span class="hljs-keyword">OF</span> CNT8 <span class="hljs-keyword">IS</span><br><span class="hljs-keyword">BEGIN</span><br>   <span class="hljs-keyword">PROCESS</span>(CLK, RST, EN, LOAD)<br>     <span class="hljs-keyword">VARIABLE</span>  CQI : <span class="hljs-built_in">STD_LOGIC_VECTOR</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>); <br>   <span class="hljs-keyword">BEGIN</span><br>       <span class="hljs-keyword">IF</span> RST = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span> CQI := (<span class="hljs-keyword">OTHERS</span> =&gt; <span class="hljs-string">&#x27;0&#x27;</span>);<br>       <span class="hljs-keyword">ELSIF</span>  CLK<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">AND</span> CLK = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span><br>             <span class="hljs-keyword">IF</span> EN = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span><br>               <span class="hljs-keyword">IF</span> LOAD = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">THEN</span> CQI := DATA;<br>               <span class="hljs-keyword">ELSIF</span> CQI &lt; <span class="hljs-number">7</span> <span class="hljs-keyword">THEN</span> CQI := CQI + <span class="hljs-number">1</span>;<br>             <span class="hljs-keyword">ELSE</span> CQI := (<span class="hljs-keyword">OTHERS</span> =&gt;<span class="hljs-string">&#x27;0&#x27;</span>);<br>           <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>     <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br><span class="hljs-keyword">IF</span> CQI = &#x27;<span class="hljs-number">111</span>&#x27; <span class="hljs-keyword">THEN</span> COUT = <span class="hljs-string">&#x27;1&#x27;</span>;<br>       <span class="hljs-keyword">ELSE</span> COUT = <span class="hljs-string">&#x27;0&#x27;</span>;<br>         <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;<br>       DOUT &lt;= CQI;<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCESS</span>;<br><span class="hljs-keyword">END</span> behav; <br></code></pre></td></tr></table></figure><p><img src="../img/EDA%E5%A4%8D%E4%B9%A0/image-20211209203637046.png" alt="image-20211209203637046"></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs VHDL"><span class="hljs-keyword">LIBRARY</span> IEEE ;<br><span class="hljs-keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword">ALL</span> ; <br><span class="hljs-keyword">ENTITY</span> EXPS <span class="hljs-keyword">IS</span><br>    <span class="hljs-keyword">PORT</span>(IN1, IN2, IN3 : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>         OUT1, OUT2 :<span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>);<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">ENTITY</span> EXPS;<br><span class="hljs-keyword">ARCHITECTURE</span> behav <span class="hljs-keyword">OF</span> EXP <span class="hljs-keyword">IS</span><br>    <span class="hljs-keyword">COMPONENT</span> EXP <br>    <span class="hljs-keyword">PORT</span>(A1, A2 : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_LOGIC</span>;<br>             Q1, Q2 : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC</span>);<br>    <span class="hljs-keyword">END</span> <span class="hljs-keyword">COMPONENT</span>;<br><span class="hljs-keyword">SIGNAL</span> A, B, C, D : <span class="hljs-built_in">STD_LOGIC</span>;<br>    <span class="hljs-keyword">BEGIN</span> <br>      u1 : EXP <span class="hljs-keyword">PORT</span> <span class="hljs-keyword">MAP</span>(IN1, IN2, A, B);<br>      u2 : EXP <span class="hljs-keyword">PORT</span> <span class="hljs-keyword">MAP</span>(A, IN3, C, D);<br>      OUT2 &lt;= <span class="hljs-keyword">NOT</span> B;<br>  OUT1 &lt;= C <span class="hljs-keyword">AND</span> B;<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">ARCHITECTURE</span> behav;<br></code></pre></td></tr></table></figure><h3 id="信号和变量定义区别"><a href="#信号和变量定义区别" class="headerlink" title="信号和变量定义区别"></a>信号和变量定义区别</h3><p>信号定义在进程外面，变量定义在进程里面。</p><h3 id="常见上升沿表示方法"><a href="#常见上升沿表示方法" class="headerlink" title="常见上升沿表示方法"></a>常见上升沿表示方法</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">CLK<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">AND</span> CLK= <span class="hljs-string">&#x27;1&#x27;</span> <br>rising_edge(CLK) <span class="hljs-comment">-- 必须打开STD_LOGIC_1164程序包 </span><br><span class="hljs-keyword">wait</span> <span class="hljs-keyword">until</span> CLK = <span class="hljs-string">&#x27;1&#x27;</span>   ;     <span class="hljs-comment">--利用wait语句</span><br>CLK=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">AND</span> CLK<span class="hljs-symbol">&#x27;LAST_VALUE</span>=<span class="hljs-string">&#x27;0&#x27;</span><br>CLK<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">AND</span> (CLK=<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">AND</span> (CLK<span class="hljs-symbol">&#x27;LAST_VALUE</span>=<span class="hljs-string">&#x27;0&#x27;</span>) <br>    <br><span class="hljs-comment">--下降</span><br>CLK<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">AND</span> CLK= <span class="hljs-string">&#x27;0&#x27;</span> <br>CLK<span class="hljs-symbol">&#x27;EVENT</span> <span class="hljs-keyword">AND</span> (CLK=<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">AND</span> (CLK<span class="hljs-symbol">&#x27;LAST_VALUE</span>=<span class="hljs-string">&#x27;1&#x27;</span>) <br>falling_edge(CLK)<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>写类似CASE···WHEN语句的条件判断语句时，一定得考虑到所有状态，不能有遗漏！</p><h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">FUNCTION</span> 函数名(参数表) <span class="hljs-keyword">RETURN</span>  数据类型         <span class="hljs-comment">--函数首</span><br><span class="hljs-keyword">FUNCTION</span>  函数名(参数表)<span class="hljs-keyword">RETURN</span>  数据类型 <span class="hljs-keyword">IS</span>   <span class="hljs-comment">-- 函数体</span><br>    [ 说明部分 ]                 <br>    <span class="hljs-keyword">BEGIN</span>                                               <br>    顺序语句 ;                       <br>    <span class="hljs-keyword">END</span> <span class="hljs-keyword">FUNCTION</span>  函数名; <br><br>        <br><span class="hljs-keyword">PROCEDURE</span> 过程名(参数表) <span class="hljs-comment">-- 过程首</span><br> <br><span class="hljs-keyword">PROCEDURE</span> 过程名(参数表) <span class="hljs-keyword">IS</span> <span class="hljs-comment">-- 过程体</span><br>    [说明部分]<br>    BIGIN<br>      顺序语句;<br>     <span class="hljs-keyword">END</span> <span class="hljs-keyword">PROCEDURE</span> 过程名 <br><span class="hljs-comment">--过程与函数的区别：</span><br>过程能返回多个变量，而函数则总是返回一个取值；<br>函数中的所有参数都是输入参数，而过程有输入参数、输出参数和双向参数；<br>过程在结构体或者进程中以语句的形式被调用，而函数经常在赋值语句或表达式中使用。 　　<br><span class="hljs-comment">--状态机</span><br>  <span class="hljs-comment">--优势</span><br>  状态机克服了纯硬件数字系统顺序方式控制不灵活的缺点；<br>由于状态机的结构相对简单，设计方案相对固定；<br>状态机容易构成性能良好的同步时序逻辑模块；<br>与VHDL的其他描述方式相比，状态机的VHDL表述丰富多样、程序层次分明，结构清晰，易读易懂；在排错、修改和模块移植方面也有其独到的好处；<br>在高速运算和控制方面，状态机更有其巨大的优势。 <br>高可靠性。  <br><br><span class="hljs-comment">--区别         </span><br>基于状态的FSM即Moore(摩尔型)FSM，状态机的输出仅是当前状态的函数，且仅在时钟跃变时发生，通常与时钟同步。<br>   基于输入的FSM即Mealy(米勒型)FSM，状态机的输出是当前状态和当前输入的函数，不与时钟同步。<br>         <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>EDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子设计总结</title>
    <link href="/2021/12/02/%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/02/%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="记录关于电子设计"><a href="#记录关于电子设计" class="headerlink" title="记录关于电子设计"></a>记录关于电子设计</h1><h2 id="选题内容"><a href="#选题内容" class="headerlink" title="选题内容"></a>选题内容</h2><p>利用焊接完的电路板完成软件的设计，本次选的题目为温度控制器与蓝牙通信，最终达到手机端能收到温度控制器测得的实时温度，其中温度控制器的核心部件是DS18B20芯片和LCD1602A液晶显示芯片，蓝牙通信的核心部件是HC-08蓝牙串口通信模块，DS18B20芯片用来实现温度测量功能；LCD1602A液晶显示芯片用来实现测量温度显示功能，HC-08蓝牙串口通信模块作为上位安卓机同52单片机通信的桥梁，达到单片机能将所测得温度发送给上位机，上位机能向单片机发送一些指令的效果。</p><p>本次所选的题目，温度控制器实现了实时显示当前温度功能，可以设置上限阈值，即温度报警值，当温度达到阈值时蜂鸣器会响起滴答滴答的声音，同时LCD显示屏右上角显示出“W”代表进入报警状态此时的温度控制器仍然正常工作，当温度低于阈值时解除报警状态。除此之外，还设计了一个APP通过蓝牙模块同单片机通信，可以达到通过手机就能查看当前单片机测得的温度，查看阈值，调整阈值的功能。此项目综合实现了多方面的功能，运用了多个芯片和组件，对单片机知识的掌握是很好的一次考察，通过此项目的实现，提高了我对单片机知识的综合掌握程度。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>温度控制器主要涉及到的硬件资源有STC89C52RC、LCD1602A显示屏芯片、DS18B20芯片、蜂鸣器、HC-08蓝牙模块。此次实验搭建的蓝牙通信APP使用的是基AppInventor2服务器的WXbit图像化编程工具，能够较为轻松的搭建出一个APP。</p><p><img src="/img/%E7%A4%BA%E6%84%8F%E5%9B%BE.PNG"></p><p><img src="/img/%E7%A4%BA%E6%84%8F%E5%9B%BE1.PNG"></p><p><img src="/img/%E7%A4%BA%E6%84%8F%E5%9B%BE1.PNG"></p><p>按照既定计划，本项目的流程为，先实现读取DS18B20模块数据，送给LCD1602模块显示，再之后就是最困难的通信模块构建，本次是基于蓝牙模块实现单片机同上位机（安卓手机）之间的通信，这就需要考虑到它们之间波特率的问题，由于此次实验通过的单片机晶振是12Mhz，12Mhz晶振通信起来误差是非常大的，这是由于其并计算初值时存在的误差。而市面上的蓝牙模块其默认波特率大都为9600，采用9600波特率，单片机根本无法同蓝牙模块建立稳定的通信，所以就要求使用AT指令调整波特率，调整到4800，并且波特率翻倍的情况下才能实现误差为0.16%的通信，较为可靠。</p><p> 其中最头疼的就是数据如何存储发送了，因为串口一次只能发送八位数据，而获取的温度值是有小数的，所以我尝试了两种方案，一是将数据分为整数部分和小数部分，分两次发送，二是将数据存为字符数组，直接发送字符数组，实践证明，第二种效果较好。</p><p><img src="/img/%E6%A6%82%E8%BF%B0.PNG"></p><p><strong>蓝牙模块同51系列单片机通信</strong></p><p>最重要的方面就是波特率设置啦，这个方面刚开始做的时候说实话踩了不少坑，因为学校电子设计提供的板子上面的晶振是<strong>12Mhz</strong>，总所周知，<strong>12Mhz</strong>的晶振通信起来误差是非常大的，这是由于其并计算初值时存在的误差。</p><p>最开始，我采用了杨文嘉老师提供的蓝牙模块，调试开始！经过一晚上的摸索，始终没能成功通信，这个时候仔细查阅发现，这个蓝牙模块波特率是固定9600的，而<strong>12Mhz</strong>的晶振产生9600的波特率，误差会达到5%左右，这是无法接受的，所以理所应当的通信不上。然后我在我的另外一个<strong>11.0592Mhz</strong>的单片机上面尝试成功。真的头很大，搞了一晚上还以为是单片机串口坏了。</p><p>之后，我购买了一个波特率可调的蓝牙模块，提供AT指令将蓝牙模块的波特率调为了4800，（经过查阅资料，发现当51单片机波特率调为4800时，波特率翻倍）这个时候误差会来到0.16%，这个误差能勉强接受，经过调试之后，通过手机上的蓝牙调试软件控制单片机P1口灯开关，成功！！！</p><p>然后就开始思考如何完成自己想做。</p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//主函数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;DS18b20.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;LCD1602.h&quot;</span></span><br><span class="hljs-keyword">char</span> RECEIVED_CMD;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flag = <span class="hljs-number">0</span> ;      <span class="hljs-comment">// 数据接收的标志位</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tvalue;<span class="hljs-comment">//温度值</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> tflag;<span class="hljs-comment">//温度正负标志</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> disdata[<span class="hljs-number">7</span>]; <span class="hljs-comment">// 温度数据，使用8字节数组来存储</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> chg[<span class="hljs-number">3</span>];                 <span class="hljs-comment">//存放阈值</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> wrong = <span class="hljs-number">30</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_Init</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 初始化串口</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_SendData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> dat)</span></span>; <span class="hljs-comment">// 串口发送数据</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_SendStr</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span></span>; <span class="hljs-comment">// 串口发送字符串</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ds1820disp</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 温度显示</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//转化阈值为字符数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> temperature , old ; <span class="hljs-comment">// 保存温度数值</span><br><span class="hljs-keyword">int</span> A=<span class="hljs-number">5000</span>;<br>UART_Init();  <span class="hljs-comment">// 串口初始化</span><br>LCD_Init();  <span class="hljs-comment">// 显示屏 初始化</span><br>LCD_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Temperature&quot;</span>);<br>P1_4 = <span class="hljs-number">0</span>;<br>temperature = ReadTemperature(); <br>old = temperature ; <br>ds1820disp(); <span class="hljs-comment">// 转换温度</span><br>LCD_ShowString(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,disdata);<br>LCD_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,wrong,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>temperature=ReadTemperature();  <span class="hljs-comment">// 读取一次新的温度</span><br>LCD_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,wrong,<span class="hljs-number">2</span>); <span class="hljs-comment">//2行13列显示wrong值</span><br>LCD_ShowChar(<span class="hljs-number">2</span>,<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;C&#x27;</span>);<br><span class="hljs-keyword">if</span> (temperature != old )   <br>&#123; <br>old = temperature;<br>ds1820disp(); <span class="hljs-comment">// 转化温度</span><br>LCD_ShowString(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,disdata); <span class="hljs-comment">// 显示温度</span><br>  &#125;<br><span class="hljs-keyword">if</span>(temperature &gt; wrong * <span class="hljs-number">10</span>)<br>&#123;<br>P1_4 = !P1_4; <span class="hljs-comment">//发出报警声</span><br><span class="hljs-keyword">while</span>(A--);<br>A=<span class="hljs-number">5000</span>;<br>LCD_ShowChar(<span class="hljs-number">1</span>,<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;W&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>LCD_ShowChar(<span class="hljs-number">1</span>,<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;N&#x27;</span>);<br>P1_4 = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(flag) <span class="hljs-comment">// 接收数据完毕一次，就会进入中断一次&#123;</span><br>flag = <span class="hljs-number">0</span> ; <span class="hljs-comment">// 将标志位还原，使得串口又可以重新接收数据</span><br><span class="hljs-keyword">if</span>(RECEIVED_CMD == <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#123;<br>UART_SendStr(disdata);<span class="hljs-comment">//向串口发送数据，发送的是当前温度</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(RECEIVED_CMD == <span class="hljs-string">&#x27;3&#x27;</span>)<br>&#123;<br>change();<br>UART_SendStr(chg);<span class="hljs-comment">//发送阈值</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(RECEIVED_CMD == <span class="hljs-string">&#x27;1&#x27;</span>)<br>&#123;<br>wrong ++ ;<span class="hljs-comment">//阈值加</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(RECEIVED_CMD  == <span class="hljs-string">&#x27;2&#x27;</span>)&#123;<br>wrong -- ;<span class="hljs-comment">//阈值减</span><br>&#125;<br>RECEIVED_CMD =<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//串口初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SCON=<span class="hljs-number">0x50</span>;<br>PCON |= <span class="hljs-number">0x80</span>;<br>TMOD &amp;= <span class="hljs-number">0x0F</span>;<span class="hljs-comment">//设置定时器模式</span><br>TMOD |= <span class="hljs-number">0x20</span>;<span class="hljs-comment">//设置定时器模式</span><br>TL1 = <span class="hljs-number">0xF3</span>;<span class="hljs-comment">//设定定时初值</span><br>TH1 = <span class="hljs-number">0xF3</span>;<span class="hljs-comment">//设定定时器重装值</span><br>ET1 = <span class="hljs-number">0</span>;<span class="hljs-comment">//禁止定时器1中断</span><br>TR1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//启动定时器1</span><br>EA=<span class="hljs-number">1</span>;<br>ES=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//打开两个外部中断</span><br>IT0 = <span class="hljs-number">1</span>;<br>IT1 = <span class="hljs-number">1</span>;<br>EX0 = <span class="hljs-number">1</span>;<br>EX1 = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_Isr</span><span class="hljs-params">()</span> interrupt 4 <span class="hljs-keyword">using</span> 1</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 串口接收中断处理</span><br><span class="hljs-keyword">if</span>(RI) &#123;<br>RI = <span class="hljs-number">0</span> ;                              <span class="hljs-comment">// 清除中断标志位</span><br>RECEIVED_CMD = SBUF ; <span class="hljs-comment">// 保存串口接收的数据</span><br>flag = <span class="hljs-number">1</span> ;           <span class="hljs-comment">// 接收结束，到循环中处理接收的数据</span><br>&#125;<br><span class="hljs-comment">// 串口发送中断处理</span><br><span class="hljs-keyword">if</span>(TI)<br>&#123;<br>TI = <span class="hljs-number">0</span> ;  <span class="hljs-comment">// 清发送中断标志位</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//开关K1</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int0</span><span class="hljs-params">()</span> interrupt 0</span><br><span class="hljs-function"></span>&#123;<br>wrong ++;<br>&#125;<br><span class="hljs-comment">//开关K2</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int1</span><span class="hljs-params">()</span> interrupt 2</span><br><span class="hljs-function"></span>&#123;<br>wrong --;<br>&#125;<br><span class="hljs-comment">//通过串口发送一位数据</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_SendData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> dat)</span></span><br><span class="hljs-function"></span>&#123;<br>ES = <span class="hljs-number">0</span> ;      <span class="hljs-comment">// 串口工作的时候禁止中断</span><br>SBUF = dat ;  <span class="hljs-comment">// 待发送的数据放到SBUF中</span><br><span class="hljs-keyword">while</span>(!TI) ;  <span class="hljs-comment">// 等待发送完毕</span><br>TI = <span class="hljs-number">0</span> ;      <span class="hljs-comment">// 清TI中断</span><br>ES = <span class="hljs-number">1</span> ;      <span class="hljs-comment">// 打开中断</span><br>&#125;<br><span class="hljs-comment">//发送字符串</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_SendStr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">do</span>&#123;<br>UART_SendData(*str);<br>&#125;<span class="hljs-keyword">while</span>(*str ++  != <span class="hljs-string">&#x27;\0&#x27;</span> ); <span class="hljs-comment">// 一直到字符串结束</span><br>&#125;<br><span class="hljs-comment">//温度转化函数，将测得的温度值转化为字符数组存放</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ds1820disp</span><span class="hljs-params">()</span></span>&#123; <br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flagdat;<br><span class="hljs-keyword">if</span>(tflag==<span class="hljs-number">0</span>)<br>  flagdat=<span class="hljs-number">0x2b</span>;<span class="hljs-comment">//正温度显示符号</span><br><span class="hljs-keyword">else</span><br>  flagdat=<span class="hljs-number">0x2d</span>;<span class="hljs-comment">//负温度显示负号:-</span><br>disdata[<span class="hljs-number">1</span>]=tvalue/<span class="hljs-number">1000</span>+<span class="hljs-number">0x30</span>;<span class="hljs-comment">//百位数</span><br>disdata[<span class="hljs-number">2</span>]=tvalue%<span class="hljs-number">1000</span>/<span class="hljs-number">100</span>+<span class="hljs-number">0x30</span>;<span class="hljs-comment">//十位数</span><br>disdata[<span class="hljs-number">3</span>]=tvalue%<span class="hljs-number">100</span>/<span class="hljs-number">10</span>+<span class="hljs-number">0x30</span>;<span class="hljs-comment">//个位数</span><br>disdata[<span class="hljs-number">4</span>]= <span class="hljs-number">0x2E</span> ;<span class="hljs-comment">//小数点</span><br>disdata[<span class="hljs-number">5</span>]=tvalue%<span class="hljs-number">10</span>/<span class="hljs-number">1</span>+<span class="hljs-number">0x30</span>;<span class="hljs-comment">//小数位</span><br><span class="hljs-keyword">if</span>(disdata[<span class="hljs-number">1</span>]==<span class="hljs-number">0x30</span>) <span class="hljs-comment">// 如果百位为0&#123;</span><br>disdata[<span class="hljs-number">0</span>]= <span class="hljs-number">0x20</span>; <span class="hljs-comment">// 第一位不显示</span><br>disdata[<span class="hljs-number">1</span>]= flagdat; <span class="hljs-comment">// 百位显示符号</span><br><span class="hljs-keyword">if</span>(disdata[<span class="hljs-number">2</span>]==<span class="hljs-number">0x30</span>) <span class="hljs-comment">//如果百位为0，十位为0&#123;</span><br>disdata[<span class="hljs-number">1</span>]=<span class="hljs-number">0x20</span>; <span class="hljs-comment">// 百位不显示符号</span><br>disdata[<span class="hljs-number">2</span>]=flagdat; <span class="hljs-comment">// 10位显示符号</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//转换阈值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span></span>&#123;<br>chg[<span class="hljs-number">0</span>] = wrong / <span class="hljs-number">10</span> + <span class="hljs-number">0x30</span>;<br>chg[<span class="hljs-number">1</span>] = wrong % <span class="hljs-number">10</span> + <span class="hljs-number">0x30</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//温度测量模块</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;DS18b20.h&quot;</span></span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tvalue;<span class="hljs-comment">//温度值</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> tflag;<span class="hljs-comment">//温度正负标志</span><br><span class="hljs-comment">//延时函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i)</span></span>&#123;<br> <span class="hljs-keyword">while</span>(i--);<br>&#125;<br><span class="hljs-comment">//初始化DS18B20</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init_DS18B20</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> x=<span class="hljs-number">0</span>;<br>DQ = <span class="hljs-number">1</span>;    <span class="hljs-comment">//让DQ置1</span><br>delay(<span class="hljs-number">8</span>);  <br>DQ = <span class="hljs-number">0</span>;    <span class="hljs-comment">//DQ拉低</span><br>delay(<span class="hljs-number">80</span>); <span class="hljs-comment">//延时480-960us</span><br>DQ = <span class="hljs-number">1</span>;    <span class="hljs-comment">//释放总线</span><br>delay(<span class="hljs-number">14</span>);<br>x=DQ;      <br>delay(<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> <span class="hljs-title">ReadOneChar</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> dat = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">8</span>;i&gt;<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//循环八次得出数据&#123;</span><br>DQ = <span class="hljs-number">0</span>; <span class="hljs-comment">//发送启动信号</span><br>dat&gt;&gt;=<span class="hljs-number">1</span>;<br>DQ = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放总线</span><br><span class="hljs-keyword">if</span>(DQ)<span class="hljs-comment">//判断是否高电平</span><br>dat|=<span class="hljs-number">0x80</span>;<span class="hljs-comment">//若是dat最高位置1，不是则置0</span><br>delay(<span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-keyword">return</span>(dat);&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteOneChar</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> dat)</span></span>&#123;<br> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (i=<span class="hljs-number">8</span>; i&gt;<span class="hljs-number">0</span>; i--)<span class="hljs-comment">//循环八次得出数据&#123;</span><br>  DQ = <span class="hljs-number">0</span>; <span class="hljs-comment">//DQ先置低电平</span><br>  DQ = dat&amp;<span class="hljs-number">0x01</span>;  <span class="hljs-comment">//取最低位</span><br>  delay(<span class="hljs-number">5</span>);<br>  DQ = <span class="hljs-number">1</span>;<br>  dat&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-comment">//由低位向高位发送数据</span><br> &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ReadTemperature</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b=<span class="hljs-number">0</span>;<br>Init_DS18B20();<span class="hljs-comment">//启动DS18B20</span><br>WriteOneChar(<span class="hljs-number">0xCC</span>); <span class="hljs-comment">//跳过读序列号的操作</span><br>WriteOneChar(<span class="hljs-number">0x44</span>); <span class="hljs-comment">//启动温度转化</span><br>Init_DS18B20();<span class="hljs-comment">//启动DS18B20</span><br>WriteOneChar(<span class="hljs-number">0xCC</span>);<span class="hljs-comment">//跳过读序列号的操作</span><br>WriteOneChar(<span class="hljs-number">0xBE</span>);<span class="hljs-comment">//读取温度寄存器等（共可读9个寄存器）前两个是温度</span><br>a=ReadOneChar();<span class="hljs-comment">//读取温度低位</span><br>b=ReadOneChar();<span class="hljs-comment">//读取温度高位</span><br>tvalue = b;<span class="hljs-comment">//处理数据</span><br>tvalue &lt;&lt;= <span class="hljs-number">8</span>;<span class="hljs-comment">//高位左移八位</span><br>tvalue = tvalue|a;<br><span class="hljs-keyword">if</span>(tvalue&lt;<span class="hljs-number">0x0fff</span>)<span class="hljs-comment">//小于0x0fff为正数</span><br>tflag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br>tvalue=~tvalue+<span class="hljs-number">1</span>;<span class="hljs-comment">//取反加一</span><br>tflag=<span class="hljs-number">1</span>;<span class="hljs-comment">//负数</span><br>  &#125;<br>tvalue = tvalue*(<span class="hljs-number">0.625</span>);<span class="hljs-comment">//温度值扩大10倍，精确到1位小数</span><br><span class="hljs-keyword">return</span>(tvalue);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>具体代码：<a href="https://github.com/KrealHtz/Studywork">https://github.com/KrealHtz/Studywork</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>电子设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acwing刷题笔记</title>
    <link href="/2021/11/02/acwing%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/11/02/acwing%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>给定 n个正整数 ai，判定每个数是否是质数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n行，每行包含一个正整数 ai。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 n 行，其中第 ii行输出第 ii 个正整数 aiai 是否为质数，是则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1001≤n≤100,<br>1≤ai≤231−11≤ai≤231−1</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>2<br>6<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//CPP</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin &gt;&gt; t;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(t))     cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-comment">#PYTHON</span><br><span class="hljs-keyword">import</span> cmath<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_prime</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">int</span>(n ** <span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,x):<br>    t = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">if</span> is_prime(t):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>think</title>
    <link href="/2021/11/02/think/"/>
    <url>/2021/11/02/think/</url>
    
    <content type="html"><![CDATA[<h1 id="行胜于言"><a href="#行胜于言" class="headerlink" title="行胜于言"></a>行胜于言</h1><h1 id="眼过千遍，不如手过一遍"><a href="#眼过千遍，不如手过一遍" class="headerlink" title="眼过千遍，不如手过一遍"></a>眼过千遍，不如手过一遍</h1><p>今天最深刻的体会，看懂很重要，但是会做比看懂更重要，眼睛往往会欺骗你，但是手不会，你若不会做，那就是不会做，没有任何办法，好了，现在要重新开始学python了，把之前学过的东西捡起来了加油！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法笔记（动态规划）</title>
    <link href="/2021/09/28/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"/>
    <url>/2021/09/28/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="算法笔记（动态规划）"><a href="#算法笔记（动态规划）" class="headerlink" title="算法笔记（动态规划）"></a>算法笔记（动态规划）</h1><p><strong>闫氏DP分析法</strong> 从集合的角度出发分析DP问题（y总yyds）、</p><p>动态规划问题：有限集中的最值</p><p>首先，状态表示(化零为整)</p><p>然后，状态计算(化整为零)</p><p><img src="/img/%E7%AE%97%E6%B3%95.PNG"></p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 <strong>N</strong> 件物品和一个容量是 <strong>V</strong> 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 Vi，价值是Wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi用空格隔开，分别表示第 i个物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h4 id="代码与思路"><a href="#代码与思路" class="headerlink" title="代码与思路"></a>代码与思路</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> f[N][N];<br><span class="hljs-keyword">int</span> V[N],W[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,v;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;v);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )  <br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;V[i]);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;W[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= v; j ++ )<br>        &#123;<br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= V[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i<span class="hljs-number">-1</span>][j-V[i]] + W[i]);<br>        &#125;<br>    cout &lt;&lt; f[n][v];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E7%AE%97%E6%B3%95-1.PNG"></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法OJ练习Ⅰ</title>
    <link href="/2021/09/09/%E7%AE%97%E6%B3%95OJ%E7%BB%83%E4%B9%A0%E2%85%A0/"/>
    <url>/2021/09/09/%E7%AE%97%E6%B3%95OJ%E7%BB%83%E4%B9%A0%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="问题-A-小雏鸟的成人式-2"><a href="#问题-A-小雏鸟的成人式-2" class="headerlink" title="问题 A: 小雏鸟的成人式 2"></a>问题 A: 小雏鸟的成人式 2</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>陶行知先生说：“我们要活的书，不要死的书 ”。</p><p>小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。</p><p>大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。</p><p>大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 <strong>恰好能且仅能</strong> 被100整除D次。</p><p>请你编写程序，找到这个数列里第N个数。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2]</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>每行对应输入，给出一个符合题意的整数</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">85</span><br></code></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">5</span><br><span class="hljs-number">1100</span><br><span class="hljs-number">850000</span><br></code></pre></td></tr></table></figure><h2 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h2><p>这道题的关键之处在于那个恰好且仅能被100整除D次出，这样的话当D取0时第一百个数就不是100了，因为100时能被D取1时能整除一次的第一个数，所以当D取0时的第一百个数就变成了101，所以没到第100个数的时候会有一个跳变，可以先加个判断，若其是第一百个数就先给它加个1；这样就不会出现错误的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> D,N;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; D &gt;&gt; N)<br>    &#123;   <br>        <span class="hljs-keyword">if</span>(N == <span class="hljs-number">100</span>)<br>            N ++ ;<br>        <span class="hljs-keyword">if</span>(D == <span class="hljs-number">1</span>)<br>            N *= <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(D == <span class="hljs-number">2</span>)<br>            N *= <span class="hljs-number">10000</span>;<br>        cout &lt;&lt; N &lt;&lt; endl;<br>    &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="问题-B-小雏鸟的成人式-3"><a href="#问题-B-小雏鸟的成人式-3" class="headerlink" title="问题 B: 小雏鸟的成人式 3"></a>问题 B: 小雏鸟的成人式 3</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>陶行知先生说：“因为道德是做人的根本。根本一坏，纵然使你有一些学问和本领，也无甚用处。”</p><p>小雏鸟们需要时刻铭记在心，不管你长成什么样的的攻城狮，都必须三观正确。</p><p>涛涛轰这一天带着爱美酱来到了一个风景如画的地方游玩。艳阳高照，他俩玩的很尽兴，但是现在他们口渴了。</p><p>涛涛轰：“我要买饮料！”</p><p>店主：“我们这里有三种饮料，矿泉水1.5元一瓶，可乐2元一瓶，橙汁3.5元一瓶。”</p><p>涛涛轰：“好的，给我一瓶矿泉水。”</p><p>说完他掏出一张N元的大钞递给店主。</p><p>店主：“我忘了提醒你了，我们这里没有找客人钱的习惯的，多的钱我们都当小费收了的，嘿嘿。”</p><p>涛涛轰：“……”</p><p>涛涛轰环顾四周，就这一家商店，况且实在太渴了，看着脸热的粉扑扑的一头汗的爱美酱，就决定在这买了。不过涛涛轰想，与其把钱当小费送给他还不如自己多买一点饮料，反正早晚都要喝，但是要尽量少让他赚小费。</p><p>现在涛涛轰希望你能帮他计算一下，最少他要给店主多少小费。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入数据的第一行是一个整数T(1&lt;=T&lt;=100)，代表测试数据的数量。然后是T行测试数据，每个测试数据只包含一个正整数N（1&lt;=N&lt;=10000），N代表小明手中钞票的面值，以分为单位。<br>注意：商店里只有题中描述的三种饮料。</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，请你输出小明最少要浪费多少钱给店主作为小费，以分为单位。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>900<br>250<br></code></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>50<br></code></pre></td></tr></table></figure><h2 id="代码及思路"><a href="#代码及思路" class="headerlink" title="代码及思路"></a>代码及思路</h2><p>首先题目中的橙汁价格=可乐价格＋矿泉水价格 ，所以我们可以不用考虑购买橙汁，可以去考虑购买可乐或者矿泉水因为可乐和矿泉水的价格只相差50分，可以转换成全部购买矿泉水，然后判断剩下的钱是否大于或者等于50分，满足，则可用矿泉水加上50分去换一瓶可乐，这样可以喝到最多的水。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> T,n;<br><span class="hljs-keyword">int</span> x,y;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)<br>    &#123;   <br>        cin &gt;&gt; n;<br>        x = n % <span class="hljs-number">150</span>;<br>        y = n / <span class="hljs-number">150</span>;<br>        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">50</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>) &#123;<br>            x -= <span class="hljs-number">50</span>;<br>            y -- ;<br>        &#125;<br>        cout &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-C-大白just大白"><a href="#问题-C-大白just大白" class="headerlink" title="问题 C: 大白just大白"></a>问题 C: 大白just大白</h2><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道，大白对学术要求是很严格的。抄作业、考试作弊神马的在大白这简直不能忍。</p><p>这不刚刚过去的期末考试。有n个学生被查出来有问题。</p><p>大白给了他们申辩的机会，每个学生可以提交一段文字，作为申辩理由。但是大白发现来的人总会有一些奇怪的理由。</p><p>大白提前列了m个常见借口关键字。他想看看来申辩的学生中最烂的申辩理由是什么。</p><p>所谓最烂申辩理由就是，申辩里，含有常见借口关键字最多的。</p><p>含有关键字，指的是，理由中出现了一串和关键字完全匹配的字符串，如果出现大写小写不同，也认为匹配。比如，关键字是 bed 理由中出现Bedroom算含有一个关键字。</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>一个输入可能有多个case，每个case第一行两个数。分别代表n 和 m</p><p>接下来m行，每行一个关键字（字符串）</p><p>再接下来n行字符串。m和n都不大于20</p><p>每一个借口和借口关键字只会包含大小写字母，长度不会超过4000个字符。</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>对于每个case输出一行字符串，表示最烂的理由。若有多个理由包含相同数目的关键字，按输入顺序输出靠前的那个。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">love</span><br><span class="hljs-attribute">cumt</span><br><span class="hljs-attribute">ACM</span><br><span class="hljs-attribute">ILoveCUMTACM</span><br><span class="hljs-attribute">cumtAACM</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">A</span><br><span class="hljs-attribute">b</span><br><span class="hljs-attribute">Ab</span><br><span class="hljs-attribute">bA</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ILoveCUMTACM</span><br><span class="hljs-attribute">Ab</span><br></code></pre></td></tr></table></figure><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p><strong>思路</strong>：开两个个string类型的数组， 将输入的字符串存起来，同时由于题目要求不考虑大小写，所以我们需要把字母全部转化为大写，这个时候就出现了一个问题，输出的时候需要输出原串，所以我们需要再开两个数组，对这两个数组进行操作，输出的时候输出原串。</p><h2 id="问题-D-小雏鸟的计算"><a href="#问题-D-小雏鸟的计算" class="headerlink" title="问题 D: 小雏鸟的计算"></a>问题 D: 小雏鸟的计算</h2><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>小雏鸟们的三角形翅膀终于长出健壮的肌肉和丰满的羽毛，已经跃跃欲试的去准备尝试挑战新的难题了。</p><p>考虑以下的算法：<br>\1.     输入 n<br>\2.     印出 n<br>\3.     如果 n = 1 结束<br>\4.     如果 n 是奇数 那么 n=3*n+1<br>\5.     否则 n=n/2<br>\6.     GOTO 2<br>例如输入 22 得到的数列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1<br>据推测此算法对任何整数而言会终止 (当打印出 1 的时候)。虽然此算法很简单，但以上的推测是否真实却无法知道。然而对所有的n ( 0 &lt; n &lt; 1000000 )来说，以上的推测已经被验证是正确的。<br>给一个输入 n 透过以上的算法我们可以得到一个数列（1作为结尾）。此数列的长度称为n的cycle length。上面提到的例子 22的 cycle length为 16.<br>问题来了：对任2个整数i，j我们想要知道介于i，j（包含i，j）之间的数所产生的数列中最大的cycle length是多少。</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入可能包含了好几行测试数据，每一行有一对整数 i，j 。 </p><p>0&lt; i，j &lt; 1000000</p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>对每一对输入 i j你应该要输出 i j和介于i j之间的数所产生的数列中最大的cycle length。</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">100 </span><span class="hljs-number">200</span><br><span class="hljs-symbol">201 </span><span class="hljs-number">210</span><br><span class="hljs-symbol">900 </span><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">100 </span><span class="hljs-number">200</span> <span class="hljs-number">125</span><br><span class="hljs-symbol">201 </span><span class="hljs-number">210</span> <span class="hljs-number">89</span><br><span class="hljs-symbol">900 </span><span class="hljs-number">1000</span> <span class="hljs-number">174</span><br></code></pre></td></tr></table></figure><h2 id="思路及代码-1"><a href="#思路及代码-1" class="headerlink" title="思路及代码"></a>思路及代码</h2><p>题目需要统计的是使用这个算法的到数列的长度，只需要定义函数判断即可。</p><p>很显然这个算法是一个递归的，可以写成递归的形式来判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> i,j;<br><span class="hljs-keyword">int</span> c ;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cycle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span>(x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) x /= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> x = <span class="hljs-number">3</span> * x + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">cycle</span>(x);<br>    c ++ ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    c = <span class="hljs-number">1</span> ;<br>    <span class="hljs-built_in">cycle</span>(y);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; i &gt;&gt; j)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l = i , r = j ;<br>        <span class="hljs-keyword">int</span> o = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(i &gt; j) <span class="hljs-built_in">swap</span>(j,i);<br>        <span class="hljs-keyword">for</span>(i; i &lt;= j; i ++ )<br>            o = <span class="hljs-built_in">max</span>(o, <span class="hljs-built_in">f</span>(i));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,l,r,o);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-E-进制转换"><a href="#问题-E-进制转换" class="headerlink" title="问题 E: 进制转换"></a>问题 E: 进制转换</h2><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个十进制正整数，然后输出它所对应的八进制数。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>输入一个十进制正整数n(1≤n≤10<em>6</em>) 。</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出n对应的八进制数，输出在一行。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10<br></code></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></table></figure><h2 id="代码及思路-1"><a href="#代码及思路-1" class="headerlink" title="代码及思路"></a>代码及思路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br> <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%o&quot;</span>,num);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-F-排列问题"><a href="#问题-F-排列问题" class="headerlink" title="问题 F: 排列问题"></a>问题 F: 排列问题</h2><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>  输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">abc,</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">abc acb <span class="hljs-keyword">bac </span><span class="hljs-keyword">bca </span>cab cba<br></code></pre></td></tr></table></figure><h2 id="代码及思路-2"><a href="#代码及思路-2" class="headerlink" title="代码及思路"></a>代码及思路</h2><p><strong>思路</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//介绍getline()函数</span><br><span class="hljs-function">istream &amp;<span class="hljs-title">getline</span><span class="hljs-params">( <span class="hljs-keyword">char</span> *buffer, streamsize num, <span class="hljs-keyword">char</span> delim )</span></span>;<br><span class="hljs-function">istream &amp;<span class="hljs-title">getline</span><span class="hljs-params">( <span class="hljs-keyword">char</span> *buffer, streamsize num )</span></span>;<br><span class="hljs-comment">//其中的buffer、num、delim的意思分别为</span><br><span class="hljs-comment">//buffer： 进行读入操作的输入流，num 存储读入的内容，delim 终结符</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">11</span>];<br>    cin.<span class="hljs-built_in">getline</span>(str, <span class="hljs-number">11</span>, <span class="hljs-string">&#x27;,&#x27;</span>);<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; str[x] != <span class="hljs-string">&#x27;\0&#x27;</span>; x++);<br>    <span class="hljs-built_in">sort</span>(str, str + x);<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) &#123;<br>            cout &lt;&lt; str[i];<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(str, str + x));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="问题-H-求第k小"><a href="#问题-H-求第k小" class="headerlink" title="问题 H: 求第k小"></a>问题 H: 求第k小</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出一行，输出第k小数。</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h2 id="思路及代码-2"><a href="#思路及代码-2" class="headerlink" title="思路及代码"></a>思路及代码</h2><p>这道题目是求的第K小的数，通常来讲，第一时间想到的就说做一个排序，然后直接输出第K小就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span> </span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> q[N];<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> x = q[l], i= l - <span class="hljs-number">1</span>,j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i] , q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l , j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span> , r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin&gt;&gt;q[i];<br><br>    <span class="hljs-built_in">quick_sort</span>(q, <span class="hljs-number">0</span> , n - <span class="hljs-number">1</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, q[m<span class="hljs-number">-1</span>]);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然还有一种效率更高的方法，记得老师上课的时候讲过，先空在这里，过会再来填坑。</p><h1 id="问题-I-沙子的质量"><a href="#问题-I-沙子的质量" class="headerlink" title="问题 I: 沙子的质量"></a>问题 I: 沙子的质量</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p><h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p><h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>合并的最小代价。</p><h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">22<br></code></pre></td></tr></table></figure><h2 id="代码及思路-3"><a href="#代码及思路-3" class="headerlink" title="代码及思路"></a>代码及思路</h2><p><strong>思路</strong>：这道题是一道动态规划问题，可以将其划分为就解最优子问题的问题，例如，将其划分为两个方面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">307</span>;<br> <br><span class="hljs-keyword">int</span> s[N];<br><span class="hljs-keyword">int</span> f[N][N];<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; s[i];<br>        s[i] += s[i - <span class="hljs-number">1</span>];<br>    &#125;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == i) &#123;<br>                f[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            f[i][j] = <span class="hljs-number">1e9</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k++) &#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="hljs-number">1</span>][j] + s[j] - s[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="问题-J-最长公共子序列"><a href="#问题-J-最长公共子序列" class="headerlink" title="问题 J: 最长公共子序列"></a>问题 J: 最长公共子序列</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。</p><h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p><h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>最长子串的长度。</p><h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abccd aecd</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="代码及思路-4"><a href="#代码及思路-4" class="headerlink" title="代码及思路"></a>代码及思路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N = <span class="hljs-number">2010</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br>string a,b;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (a&gt;=b)  <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> b; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,len_a,len_b;    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    len_a = a.<span class="hljs-built_in">length</span>();<br>    len_b = b.<span class="hljs-built_in">length</span>();      <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= len_a;i ++ )<br>       &#123;<br>       <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span> ;j &lt;= len_b;j ++ )<br>           &#123;<br>           <span class="hljs-keyword">if</span> (a[i<span class="hljs-number">-1</span>] == b[j<span class="hljs-number">-1</span>]) f[i][j] = f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>           &#125;<br>       &#125;     <br>    cout &lt;&lt; f[len_a][len_b];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p><strong>快速幂</strong>（<strong>Exponentiation by squaring</strong>，平方求幂）是一种简单而有效的小算法，它可以以<img src="https://www.zhihu.com/equation?tex=O(%5Clog+n)" alt="[公式]">的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：</strong>最朴素的想法，7<em>7=49，49</em>7=343，… 一步一步算，共进行了<strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：</strong>先算7的5次方，即7<em>7</em>7<em>7</em>7，再算它的平方，共进行了<strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：</strong>先算7<em>7得49，则7的5次方为49</em>49*7，再算它的平方，共进行了<strong>4次</strong>乘法。</p><p>模仿这样的过程，我们得到一个在 <img src="https://www.zhihu.com/equation?tex=O(%5Clog+n)" alt="[公式]"> 时间内计算出幂的算法，也就是快速幂。</p><h2 id="递归快速幂"><a href="#递归快速幂" class="headerlink" title="递归快速幂"></a>递归快速幂</h2><p>刚刚我们用到的，无非是一个<strong>二分</strong>的思路。我们很自然地可以得到一个递归方程：</p><p><img src="https://www.zhihu.com/equation?tex=a%5En=%5Cbegin%7Bcases%7Da%5E%7Bn-1%7D%5Ccdot+a,&%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+odd%7D+%5C%5C+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Ccdot+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D,+&%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+even+but+not+0%7D%5C%5C+1,&%5Ctext%7Bif+%7D+n=0%5Cend%7Bcases%7D" alt="[公式]"></p><p>计算a的n次方，如果n是偶数（不为0），那么就<strong>先计算a的n/2次方，然后平方</strong>；如果n是奇数，那么就<strong>先计算a的n-1次方，再乘上a</strong>；递归出口是<strong>a的0次方为1</strong>。</p><p>递归快速幂的思路非常自然，代码也很简单（直接把递归方程翻译成代码即可）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归快速幂</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(a, n - <span class="hljs-number">1</span>) * a;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">qpow</span>(a, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> temp * temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这个temp变量是必要的，因为如果不把<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D" alt="[公式]">记录下来，直接写成qpow(a, n /2)*qpow(a, n /2)，那会计算两次<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D" alt="[公式]">，整个算法就退化为了 <img src="https://www.zhihu.com/equation?tex=O(n)" alt="[公式]"> 。</p><p>在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是<strong>步步取模</strong>，如果MOD较大，还应当<strong>开long long</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归快速幂（对大素数取模）</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(a, n - <span class="hljs-number">1</span>) * a % MOD;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll temp = <span class="hljs-built_in">qpow</span>(a, n / <span class="hljs-number">2</span>) % MOD;<br>        <span class="hljs-keyword">return</span> temp * temp % MOD;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家知道，递归虽然<strong>简洁</strong>，但会产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong>。</p><h2 id="非递归快速幂"><a href="#非递归快速幂" class="headerlink" title="非递归快速幂"></a>非递归快速幂</h2><p>我们换一个角度来引入非递归的快速幂。还是7的10次方，但这次，我们把10写成<strong>二进制</strong>的形式，也就是 <img src="https://www.zhihu.com/equation?tex=(1010)_2" alt="[公式]"> 。</p><p>现在我们要计算 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(1010)_2%7D" alt="[公式]"> ，可以怎么做？我们很自然地想到可以把它拆分为 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(1000)_2%7D+%5Ccdot+7%5E%7B(10)_2%7D+" alt="[公式]"> . 实际上，对于任意的整数，我们都可以把它拆成若干个 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(100...)_2%7D" alt="[公式]"> 的形式相乘。而这些<img src="https://www.zhihu.com/equation?tex=7%5E%7B(100...)_2%7D" alt="[公式]">，恰好就是 <img src="https://www.zhihu.com/equation?tex=7%5E1" alt="[公式]"> 、<img src="https://www.zhihu.com/equation?tex=7%5E2" alt="[公式]">、<img src="https://www.zhihu.com/equation?tex=7%5E4" alt="[公式]">……我们只需<strong>不断把底数平方</strong>就可以算出它们。</p><p>我们先看代码，再来仔细推敲这个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//非递归快速幂</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)        <span class="hljs-comment">//如果n的当前末位为1</span><br>            ans *= a;  <span class="hljs-comment">//ans乘上当前的a</span><br>        a *= a;        <span class="hljs-comment">//a自乘</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>;       <span class="hljs-comment">//n往右移一位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>最初ans为1，然后我们一位一位算：</p><p>1010的最后一位是0，所以a^1这一位不要。然后1010变为101，a变为a^2。</p><p>101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为10，a再自乘。</p><p>10的最后一位是0，跳过，右移，自乘。</p><p>然后1的最后一位是1，ans再乘上a^8。循环结束，返回结果。</p><p><img src="https://pic3.zhimg.com/v2-e99e321dcff33699093cde2876424dbe_r.jpg" alt="preview"></p><p>这里的位运算符，**&gt;&gt;<strong>是右移，表示把二进制数</strong>往右移一位<strong>，相当于/2；&amp;是按位与，&amp;1可以理解为</strong>取出二进制数的最后一位**，相当于%2==1。这么一等价，是不是看出了递归和非递归的快速幂的关系了？虽然非递归快速幂因为牵扯到二进制理解起来稍微复杂一点，但基本思路其实和递归快速幂没有太大的出入。</p><h2 id="快速幂的拓展"><a href="#快速幂的拓展" class="headerlink" title="快速幂的拓展"></a>快速幂的拓展</h2><p>上面所述的都是<strong>整数</strong>的快速幂，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。下面给出一个模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//泛型的非递归快速幂</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">qpow</span><span class="hljs-params">(T a, ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    T ans = <span class="hljs-number">1</span>; <span class="hljs-comment">// 赋值为乘法单位元，可能要根据构造函数修改</span><br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>            ans = ans * a; <span class="hljs-comment">// 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = a * a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，<strong>矩阵快速幂</strong>的一个经典应用是求斐波那契数列：</p><p>子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N = <span class="hljs-number">2010</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br>string a,b;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (a&gt;=b)  <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> b; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,len_a,len_b;    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    len_a = a.<span class="hljs-built_in">length</span>();<br>    len_b = b.<span class="hljs-built_in">length</span>();      <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= len_a;i ++ )<br>       &#123;<br>       <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span> ;j &lt;= len_b;j ++ )<br>           &#123; <br>           <span class="hljs-keyword">if</span> (a[i<span class="hljs-number">-1</span>] == b[j<span class="hljs-number">-1</span>]) f[i][j] = f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>           &#125;<br>       &#125;     <br>    cout &lt;&lt; f[len_a][len_b];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速幂部分知识摘自于：<a href="https://zhuanlan.zhihu.com/p/95902286">https://zhuanlan.zhihu.com/p/95902286</a></p>]]></content>
    
    
    <categories>
      
      <category>算法OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微机原理实验</title>
    <link href="/2021/09/08/first/"/>
    <url>/2021/09/08/first/</url>
    
    <content type="html"><![CDATA[<h1 id="8255芯片＋8254芯片实现硬延时跑马灯"><a href="#8255芯片＋8254芯片实现硬延时跑马灯" class="headerlink" title="8255芯片＋8254芯片实现硬延时跑马灯"></a>8255芯片＋8254芯片实现硬延时跑马灯</h1><p><strong>仅供参考</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs xml">；此案例中8255的四个端口地址依次为 280H 281H 282H 283H<br>; 8254的依次为 298H 299H 29AH 29BH <br>；8255接Y0 8254接Y3<br>；此程序实现目标，通过开关D0来启动或终止跑马灯，每个灯亮延时2s<br>；这里是用8255的A口来输入8254处理过的脉冲信号，B口输出，C口输入开关状态<br>CODE SEGMENT<br>       ASSUME CS:CODE<br><br>START: <br>       MOV DX,283H<br>       MOV AL,10011001B <br>       OUT DX,AL；向8255写入控制字<br>       <br>-- 初始化8254 使其达到一个2s的延时效果---这里使用了一个级联的方式，使用了1号通道和2号通道级联；<br>       MOV AL,01110101B    ；写入8254 1号通道的控制字<br>       MOV DX,29BH<br>       OUT DX,AL<br>       MOV AL,00H<br>       MOV DX,299H                                      <br>       OUT DX,AL<br>       MOV AL,10H<br>       OUT DX,AL <br>                 <br>       MOV AL,10110111B ；写入8254 2号通道的控制字<br>       MOV DX,29BH<br>       OUT DX,AL<br>       MOV AL,00H<br>       MOV DX,29AH<br>       OUT DX,AL<br>       MOV AL,40H<br>       OUT DX,AL ；初始化结束<br><br>       MOV BL,04H；设定初值，暂存于BL中<br>；读入开关状态，是否是D0接入<br>T1:<br>    MOV DX,282H<br>    IN  AL,DX<br>    TEST AL,01H ；00000001B<br>    JZ T1<br>；读8254输出电平的状态，若为低电平则继续循环，等待高电平到来<br>T2:<br>   MOV DX,280H<br>   IN  AL,DX<br>   TEST AL,01H<br>   JZ T2<br>；前面都准备就绪，开始让第三个灯亮<br>   MOV DX,281H<br>   MOV AL,BL<br>   OUT DX,AL<br> T4:<br>；测试此时是否为高电平，<br>   MOV DX,280H<br>   IN  AL,DX<br>   TEST AL,01H<br>   JNZ T4 <br>；当此刻为高电平，则完成了延时过程，实现了延时2s<br> ；循环左移一位<br>    ROL BL,1<br>    JMP T1  <br><br>CODE ENDS<br>END START<br></code></pre></td></tr></table></figure><p><strong>课程实验总结，仅供参考。</strong></p>]]></content>
    
    
    <categories>
      
      <category>微机原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
