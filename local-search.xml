<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法OJ练习Ⅰ</title>
    <link href="/2021/09/09/%E7%AE%97%E6%B3%95OJ%E7%BB%83%E4%B9%A0%E2%85%A0/"/>
    <url>/2021/09/09/%E7%AE%97%E6%B3%95OJ%E7%BB%83%E4%B9%A0%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="问题-A-小雏鸟的成人式-2"><a href="#问题-A-小雏鸟的成人式-2" class="headerlink" title="问题 A: 小雏鸟的成人式 2"></a>问题 A: 小雏鸟的成人式 2</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>陶行知先生说：“我们要活的书，不要死的书 ”。</p><p>小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。</p><p>大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。</p><p>大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 <strong>恰好能且仅能</strong> 被100整除D次。</p><p>请你编写程序，找到这个数列里第N个数。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2]</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>每行对应输入，给出一个符合题意的整数</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">85</span><br></code></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">5</span><br><span class="hljs-number">1100</span><br><span class="hljs-number">850000</span><br></code></pre></td></tr></table></figure><h2 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h2><p>这道题的关键之处在于那个恰好且仅能被100整除D次出，这样的话当D取0时第一百个数就不是100了，因为100时能被D取1时能整除一次的第一个数，所以当D取0时的第一百个数就变成了101，所以没到第100个数的时候会有一个跳变，可以先加个判断，若其是第一百个数就先给它加个1；这样就不会出现错误的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> D,N;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; D &gt;&gt; N)<br>    &#123;   <br>        <span class="hljs-keyword">if</span>(N == <span class="hljs-number">100</span>)<br>            N ++ ;<br>        <span class="hljs-keyword">if</span>(D == <span class="hljs-number">1</span>)<br>            N *= <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(D == <span class="hljs-number">2</span>)<br>            N *= <span class="hljs-number">10000</span>;<br>        cout &lt;&lt; N &lt;&lt; endl;<br>    &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="问题-B-小雏鸟的成人式-3"><a href="#问题-B-小雏鸟的成人式-3" class="headerlink" title="问题 B: 小雏鸟的成人式 3"></a>问题 B: 小雏鸟的成人式 3</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>陶行知先生说：“因为道德是做人的根本。根本一坏，纵然使你有一些学问和本领，也无甚用处。”</p><p>小雏鸟们需要时刻铭记在心，不管你长成什么样的的攻城狮，都必须三观正确。</p><p>涛涛轰这一天带着爱美酱来到了一个风景如画的地方游玩。艳阳高照，他俩玩的很尽兴，但是现在他们口渴了。</p><p>涛涛轰：“我要买饮料！”</p><p>店主：“我们这里有三种饮料，矿泉水1.5元一瓶，可乐2元一瓶，橙汁3.5元一瓶。”</p><p>涛涛轰：“好的，给我一瓶矿泉水。”</p><p>说完他掏出一张N元的大钞递给店主。</p><p>店主：“我忘了提醒你了，我们这里没有找客人钱的习惯的，多的钱我们都当小费收了的，嘿嘿。”</p><p>涛涛轰：“……”</p><p>涛涛轰环顾四周，就这一家商店，况且实在太渴了，看着脸热的粉扑扑的一头汗的爱美酱，就决定在这买了。不过涛涛轰想，与其把钱当小费送给他还不如自己多买一点饮料，反正早晚都要喝，但是要尽量少让他赚小费。</p><p>现在涛涛轰希望你能帮他计算一下，最少他要给店主多少小费。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入数据的第一行是一个整数T(1&lt;=T&lt;=100)，代表测试数据的数量。然后是T行测试数据，每个测试数据只包含一个正整数N（1&lt;=N&lt;=10000），N代表小明手中钞票的面值，以分为单位。<br>注意：商店里只有题中描述的三种饮料。</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，请你输出小明最少要浪费多少钱给店主作为小费，以分为单位。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>900<br>250<br></code></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>50<br></code></pre></td></tr></table></figure><h2 id="代码及思路"><a href="#代码及思路" class="headerlink" title="代码及思路"></a>代码及思路</h2><p>首先题目中的橙汁价格=可乐价格＋矿泉水价格 ，所以我们可以不用考虑购买橙汁，可以去考虑购买可乐或者矿泉水因为可乐和矿泉水的价格只相差50分，可以转换成全部购买矿泉水，然后判断剩下的钱是否大于或者等于50分，满足，则可用矿泉水加上50分去换一瓶可乐，这样可以喝到最多的水。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> T,n;<br><span class="hljs-keyword">int</span> x,y;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)<br>    &#123;   <br>        cin &gt;&gt; n;<br>        x = n % <span class="hljs-number">150</span>;<br>        y = n / <span class="hljs-number">150</span>;<br>        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">50</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>) &#123;<br>            x -= <span class="hljs-number">50</span>;<br>            y -- ;<br>        &#125;<br>        cout &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p><strong>快速幂</strong>（<strong>Exponentiation by squaring</strong>，平方求幂）是一种简单而有效的小算法，它可以以<img src="https://www.zhihu.com/equation?tex=O(%5Clog+n)" alt="[公式]">的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：</strong>最朴素的想法，7<em>7=49，49</em>7=343，… 一步一步算，共进行了<strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：</strong>先算7的5次方，即7<em>7</em>7<em>7</em>7，再算它的平方，共进行了<strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：</strong>先算7<em>7得49，则7的5次方为49</em>49*7，再算它的平方，共进行了<strong>4次</strong>乘法。</p><p>模仿这样的过程，我们得到一个在 <img src="https://www.zhihu.com/equation?tex=O(%5Clog+n)" alt="[公式]"> 时间内计算出幂的算法，也就是快速幂。</p><h2 id="递归快速幂"><a href="#递归快速幂" class="headerlink" title="递归快速幂"></a>递归快速幂</h2><p>刚刚我们用到的，无非是一个<strong>二分</strong>的思路。我们很自然地可以得到一个递归方程：</p><p><img src="https://www.zhihu.com/equation?tex=a%5En=%5Cbegin%7Bcases%7Da%5E%7Bn-1%7D%5Ccdot+a,&%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+odd%7D+%5C%5C+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Ccdot+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D,+&%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+even+but+not+0%7D%5C%5C+1,&%5Ctext%7Bif+%7D+n=0%5Cend%7Bcases%7D" alt="[公式]"></p><p>计算a的n次方，如果n是偶数（不为0），那么就<strong>先计算a的n/2次方，然后平方</strong>；如果n是奇数，那么就<strong>先计算a的n-1次方，再乘上a</strong>；递归出口是<strong>a的0次方为1</strong>。</p><p>递归快速幂的思路非常自然，代码也很简单（直接把递归方程翻译成代码即可）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归快速幂</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(a, n - <span class="hljs-number">1</span>) * a;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">qpow</span>(a, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> temp * temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这个temp变量是必要的，因为如果不把<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D" alt="[公式]">记录下来，直接写成qpow(a, n /2)*qpow(a, n /2)，那会计算两次<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D" alt="[公式]">，整个算法就退化为了 <img src="https://www.zhihu.com/equation?tex=O(n)" alt="[公式]"> 。</p><p>在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是<strong>步步取模</strong>，如果MOD较大，还应当<strong>开long long</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归快速幂（对大素数取模）</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(a, n - <span class="hljs-number">1</span>) * a % MOD;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll temp = <span class="hljs-built_in">qpow</span>(a, n / <span class="hljs-number">2</span>) % MOD;<br>        <span class="hljs-keyword">return</span> temp * temp % MOD;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家知道，递归虽然<strong>简洁</strong>，但会产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong>。</p><h2 id="非递归快速幂"><a href="#非递归快速幂" class="headerlink" title="非递归快速幂"></a>非递归快速幂</h2><p>我们换一个角度来引入非递归的快速幂。还是7的10次方，但这次，我们把10写成<strong>二进制</strong>的形式，也就是 <img src="https://www.zhihu.com/equation?tex=(1010)_2" alt="[公式]"> 。</p><p>现在我们要计算 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(1010)_2%7D" alt="[公式]"> ，可以怎么做？我们很自然地想到可以把它拆分为 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(1000)_2%7D+%5Ccdot+7%5E%7B(10)_2%7D+" alt="[公式]"> . 实际上，对于任意的整数，我们都可以把它拆成若干个 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(100...)_2%7D" alt="[公式]"> 的形式相乘。而这些<img src="https://www.zhihu.com/equation?tex=7%5E%7B(100...)_2%7D" alt="[公式]">，恰好就是 <img src="https://www.zhihu.com/equation?tex=7%5E1" alt="[公式]"> 、<img src="https://www.zhihu.com/equation?tex=7%5E2" alt="[公式]">、<img src="https://www.zhihu.com/equation?tex=7%5E4" alt="[公式]">……我们只需<strong>不断把底数平方</strong>就可以算出它们。</p><p>我们先看代码，再来仔细推敲这个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//非递归快速幂</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)        <span class="hljs-comment">//如果n的当前末位为1</span><br>            ans *= a;  <span class="hljs-comment">//ans乘上当前的a</span><br>        a *= a;        <span class="hljs-comment">//a自乘</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>;       <span class="hljs-comment">//n往右移一位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>最初ans为1，然后我们一位一位算：</p><p>1010的最后一位是0，所以a^1这一位不要。然后1010变为101，a变为a^2。</p><p>101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为10，a再自乘。</p><p>10的最后一位是0，跳过，右移，自乘。</p><p>然后1的最后一位是1，ans再乘上a^8。循环结束，返回结果。</p><p><img src="https://pic3.zhimg.com/v2-e99e321dcff33699093cde2876424dbe_r.jpg" alt="preview"></p><p>这里的位运算符，**&gt;&gt;<strong>是右移，表示把二进制数</strong>往右移一位<strong>，相当于/2；&amp;是按位与，&amp;1可以理解为</strong>取出二进制数的最后一位**，相当于%2==1。这么一等价，是不是看出了递归和非递归的快速幂的关系了？虽然非递归快速幂因为牵扯到二进制理解起来稍微复杂一点，但基本思路其实和递归快速幂没有太大的出入。</p><h2 id="快速幂的拓展"><a href="#快速幂的拓展" class="headerlink" title="快速幂的拓展"></a>快速幂的拓展</h2><p>上面所述的都是<strong>整数</strong>的快速幂，但其实，在算 <img src="https://www.zhihu.com/equation?tex=a%5En" alt="[公式]"> 时，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。下面给出一个模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//泛型的非递归快速幂</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">qpow</span><span class="hljs-params">(T a, ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    T ans = <span class="hljs-number">1</span>; <span class="hljs-comment">// 赋值为乘法单位元，可能要根据构造函数修改</span><br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>            ans = ans * a; <span class="hljs-comment">// 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = a * a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，较复杂类型的快速幂的时间复杂度不再是简单的 <img src="https://www.zhihu.com/equation?tex=O(%5Clog+n)" alt="[公式]"> ，它与底数的乘法的时间复杂度有关。</p><p>例如，<strong>矩阵快速幂</strong>的一个经典应用是求斐波那契数列：</p><p>子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N = <span class="hljs-number">2010</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br>string a,b;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (a&gt;=b)  <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> b; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,len_a,len_b;    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    len_a = a.<span class="hljs-built_in">length</span>();<br>    len_b = b.<span class="hljs-built_in">length</span>();      <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= len_a;i ++ )<br>       &#123;<br>       <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span> ;j &lt;= len_b;j ++ )<br>           &#123;<br>           <span class="hljs-keyword">if</span> (a[i<span class="hljs-number">-1</span>] == b[j<span class="hljs-number">-1</span>]) f[i][j] = f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>           &#125;<br>       &#125;     <br>    cout &lt;&lt; f[len_a][len_b];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速幂部分知识摘自于：<a href="https://zhuanlan.zhihu.com/p/95902286">https://zhuanlan.zhihu.com/p/95902286</a></p>]]></content>
    
    
    <categories>
      
      <category>算法OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微机原理实验</title>
    <link href="/2021/09/08/first/"/>
    <url>/2021/09/08/first/</url>
    
    <content type="html"><![CDATA[<h1 id="8255芯片＋8254芯片实现硬延时跑马灯"><a href="#8255芯片＋8254芯片实现硬延时跑马灯" class="headerlink" title="8255芯片＋8254芯片实现硬延时跑马灯"></a>8255芯片＋8254芯片实现硬延时跑马灯</h1><p><strong>仅供参考</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs xml">；此案例中8255的四个端口地址依次为 280H 281H 282H 283H<br>; 8254的依次为 298H 299H 29AH 29BH <br>；8255接Y0 8254接Y3<br>；此程序实现目标，通过开关D0来启动或终止跑马灯，每个灯亮延时2s<br>；这里是用8255的A口来输入8254处理过的脉冲信号，B口输出，C口输入开关状态<br>CODE SEGMENT<br>       ASSUME CS:CODE<br><br>START: <br>       MOV DX,283H<br>       MOV AL,10011001B <br>       OUT DX,AL；向8255写入控制字<br>       <br>-- 初始化8254 使其达到一个2s的延时效果---这里使用了一个级联的方式，使用了1号通道和2号通道级联；<br>       MOV AL,01110101B    ；写入8254 1号通道的控制字<br>       MOV DX,29BH<br>       OUT DX,AL<br>       MOV AL,00H<br>       MOV DX,299H                                      <br>       OUT DX,AL<br>       MOV AL,10H<br>       OUT DX,AL <br>                 <br>       MOV AL,10110111B ；写入8254 2号通道的控制字<br>       MOV DX,29BH<br>       OUT DX,AL<br>       MOV AL,00H<br>       MOV DX,29AH<br>       OUT DX,AL<br>       MOV AL,40H<br>       OUT DX,AL ；初始化结束<br><br>       MOV BL,04H；设定初值，暂存于BL中<br>；读入开关状态，是否是D0接入<br>T1:<br>    MOV DX,282H<br>    IN  AL,DX<br>    TEST AL,01H ；00000001B<br>    JZ T1<br>；读8254输出电平的状态，若为低电平则继续循环，等待高电平到来<br>T2:<br>   MOV DX,280H<br>   IN  AL,DX<br>   TEST AL,01H<br>   JZ T2<br>；前面都准备就绪，开始让第三个灯亮<br>   MOV DX,281H<br>   MOV AL,BL<br>   OUT DX,AL<br> T4:<br>；测试此时是否为高电平，<br>   MOV DX,280H<br>   IN  AL,DX<br>   TEST AL,01H<br>   JNZ T4 <br>；当此刻为高电平，则完成了延时过程，实现了延时2s<br> ；循环左移一位<br>    ROL BL,1<br>    JMP T1  <br><br>CODE ENDS<br>END START<br></code></pre></td></tr></table></figure><p><strong>课程实验总结，仅供参考。</strong></p>]]></content>
    
    
    <categories>
      
      <category>微机原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
