<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"/>
    <url>/2021/09/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="算法笔记（动态规划）"><a href="#算法笔记（动态规划）" class="headerlink" title="算法笔记（动态规划）"></a>算法笔记（动态规划）</h1><p><strong>闫氏DP分析法</strong> 从集合的角度出发分析DP问题（y总yyds）、</p><p>动态规划问题：有限集中的最值</p><p>首先，状态表示(化零为整)</p><p>然后，状态计算(化整为零)</p><p><img src="../img/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/%E7%AE%97%E6%B3%95-16325575986721.PNG" alt="算法"></p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 <strong>N</strong> 件物品和一个容量是 <strong>V</strong> 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 Vi，价值是Wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi用空格隔开，分别表示第 i个物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h4 id="代码与思路"><a href="#代码与思路" class="headerlink" title="代码与思路"></a>代码与思路</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">int</span> f[N][N];<br><span class="hljs-keyword">int</span> V[N],W[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,v;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;v);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )  <br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;V[i]);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;W[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= v; j ++ )<br>        &#123;<br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= V[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i<span class="hljs-number">-1</span>][j-V[i]] + W[i]);<br>        &#125;<br>    cout &lt;&lt; f[n][v];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法OJ练习Ⅰ</title>
    <link href="/2021/09/09/%E7%AE%97%E6%B3%95OJ%E7%BB%83%E4%B9%A0%E2%85%A0/"/>
    <url>/2021/09/09/%E7%AE%97%E6%B3%95OJ%E7%BB%83%E4%B9%A0%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="问题-A-小雏鸟的成人式-2"><a href="#问题-A-小雏鸟的成人式-2" class="headerlink" title="问题 A: 小雏鸟的成人式 2"></a>问题 A: 小雏鸟的成人式 2</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>陶行知先生说：“我们要活的书，不要死的书 ”。</p><p>小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。</p><p>大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。</p><p>大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 <strong>恰好能且仅能</strong> 被100整除D次。</p><p>请你编写程序，找到这个数列里第N个数。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2]</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>每行对应输入，给出一个符合题意的整数</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">85</span><br></code></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">5</span><br><span class="hljs-number">1100</span><br><span class="hljs-number">850000</span><br></code></pre></td></tr></table></figure><h2 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h2><p>这道题的关键之处在于那个恰好且仅能被100整除D次出，这样的话当D取0时第一百个数就不是100了，因为100时能被D取1时能整除一次的第一个数，所以当D取0时的第一百个数就变成了101，所以没到第100个数的时候会有一个跳变，可以先加个判断，若其是第一百个数就先给它加个1；这样就不会出现错误的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> D,N;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; D &gt;&gt; N)<br>    &#123;   <br>        <span class="hljs-keyword">if</span>(N == <span class="hljs-number">100</span>)<br>            N ++ ;<br>        <span class="hljs-keyword">if</span>(D == <span class="hljs-number">1</span>)<br>            N *= <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(D == <span class="hljs-number">2</span>)<br>            N *= <span class="hljs-number">10000</span>;<br>        cout &lt;&lt; N &lt;&lt; endl;<br>    &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="问题-B-小雏鸟的成人式-3"><a href="#问题-B-小雏鸟的成人式-3" class="headerlink" title="问题 B: 小雏鸟的成人式 3"></a>问题 B: 小雏鸟的成人式 3</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>陶行知先生说：“因为道德是做人的根本。根本一坏，纵然使你有一些学问和本领，也无甚用处。”</p><p>小雏鸟们需要时刻铭记在心，不管你长成什么样的的攻城狮，都必须三观正确。</p><p>涛涛轰这一天带着爱美酱来到了一个风景如画的地方游玩。艳阳高照，他俩玩的很尽兴，但是现在他们口渴了。</p><p>涛涛轰：“我要买饮料！”</p><p>店主：“我们这里有三种饮料，矿泉水1.5元一瓶，可乐2元一瓶，橙汁3.5元一瓶。”</p><p>涛涛轰：“好的，给我一瓶矿泉水。”</p><p>说完他掏出一张N元的大钞递给店主。</p><p>店主：“我忘了提醒你了，我们这里没有找客人钱的习惯的，多的钱我们都当小费收了的，嘿嘿。”</p><p>涛涛轰：“……”</p><p>涛涛轰环顾四周，就这一家商店，况且实在太渴了，看着脸热的粉扑扑的一头汗的爱美酱，就决定在这买了。不过涛涛轰想，与其把钱当小费送给他还不如自己多买一点饮料，反正早晚都要喝，但是要尽量少让他赚小费。</p><p>现在涛涛轰希望你能帮他计算一下，最少他要给店主多少小费。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入数据的第一行是一个整数T(1&lt;=T&lt;=100)，代表测试数据的数量。然后是T行测试数据，每个测试数据只包含一个正整数N（1&lt;=N&lt;=10000），N代表小明手中钞票的面值，以分为单位。<br>注意：商店里只有题中描述的三种饮料。</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，请你输出小明最少要浪费多少钱给店主作为小费，以分为单位。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>900<br>250<br></code></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>50<br></code></pre></td></tr></table></figure><h2 id="代码及思路"><a href="#代码及思路" class="headerlink" title="代码及思路"></a>代码及思路</h2><p>首先题目中的橙汁价格=可乐价格＋矿泉水价格 ，所以我们可以不用考虑购买橙汁，可以去考虑购买可乐或者矿泉水因为可乐和矿泉水的价格只相差50分，可以转换成全部购买矿泉水，然后判断剩下的钱是否大于或者等于50分，满足，则可用矿泉水加上50分去换一瓶可乐，这样可以喝到最多的水。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> T,n;<br><span class="hljs-keyword">int</span> x,y;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)<br>    &#123;   <br>        cin &gt;&gt; n;<br>        x = n % <span class="hljs-number">150</span>;<br>        y = n / <span class="hljs-number">150</span>;<br>        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">50</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>) &#123;<br>            x -= <span class="hljs-number">50</span>;<br>            y -- ;<br>        &#125;<br>        cout &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-C-大白just大白"><a href="#问题-C-大白just大白" class="headerlink" title="问题 C: 大白just大白"></a>问题 C: 大白just大白</h2><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道，大白对学术要求是很严格的。抄作业、考试作弊神马的在大白这简直不能忍。</p><p>这不刚刚过去的期末考试。有n个学生被查出来有问题。</p><p>大白给了他们申辩的机会，每个学生可以提交一段文字，作为申辩理由。但是大白发现来的人总会有一些奇怪的理由。</p><p>大白提前列了m个常见借口关键字。他想看看来申辩的学生中最烂的申辩理由是什么。</p><p>所谓最烂申辩理由就是，申辩里，含有常见借口关键字最多的。</p><p>含有关键字，指的是，理由中出现了一串和关键字完全匹配的字符串，如果出现大写小写不同，也认为匹配。比如，关键字是 bed 理由中出现Bedroom算含有一个关键字。</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>一个输入可能有多个case，每个case第一行两个数。分别代表n 和 m</p><p>接下来m行，每行一个关键字（字符串）</p><p>再接下来n行字符串。m和n都不大于20</p><p>每一个借口和借口关键字只会包含大小写字母，长度不会超过4000个字符。</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>对于每个case输出一行字符串，表示最烂的理由。若有多个理由包含相同数目的关键字，按输入顺序输出靠前的那个。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">love</span><br><span class="hljs-attribute">cumt</span><br><span class="hljs-attribute">ACM</span><br><span class="hljs-attribute">ILoveCUMTACM</span><br><span class="hljs-attribute">cumtAACM</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">A</span><br><span class="hljs-attribute">b</span><br><span class="hljs-attribute">Ab</span><br><span class="hljs-attribute">bA</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ILoveCUMTACM</span><br><span class="hljs-attribute">Ab</span><br></code></pre></td></tr></table></figure><h2 id="解题思路及代码"><a href="#解题思路及代码" class="headerlink" title="解题思路及代码"></a>解题思路及代码</h2><p><strong>思路</strong>：开两个个string类型的数组， 将输入的字符串存起来，同时由于题目要求不考虑大小写，所以我们需要把字母全部转化为大写，这个时候就出现了一个问题，输出的时候需要输出原串，所以我们需要再开两个数组，对这两个数组进行操作，输出的时候输出原串。</p><h2 id="问题-D-小雏鸟的计算"><a href="#问题-D-小雏鸟的计算" class="headerlink" title="问题 D: 小雏鸟的计算"></a>问题 D: 小雏鸟的计算</h2><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>小雏鸟们的三角形翅膀终于长出健壮的肌肉和丰满的羽毛，已经跃跃欲试的去准备尝试挑战新的难题了。</p><p>考虑以下的算法：<br>\1.     输入 n<br>\2.     印出 n<br>\3.     如果 n = 1 结束<br>\4.     如果 n 是奇数 那么 n=3*n+1<br>\5.     否则 n=n/2<br>\6.     GOTO 2<br>例如输入 22 得到的数列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1<br>据推测此算法对任何整数而言会终止 (当打印出 1 的时候)。虽然此算法很简单，但以上的推测是否真实却无法知道。然而对所有的n ( 0 &lt; n &lt; 1000000 )来说，以上的推测已经被验证是正确的。<br>给一个输入 n 透过以上的算法我们可以得到一个数列（1作为结尾）。此数列的长度称为n的cycle length。上面提到的例子 22的 cycle length为 16.<br>问题来了：对任2个整数i，j我们想要知道介于i，j（包含i，j）之间的数所产生的数列中最大的cycle length是多少。</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入可能包含了好几行测试数据，每一行有一对整数 i，j 。 </p><p>0&lt; i，j &lt; 1000000</p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>对每一对输入 i j你应该要输出 i j和介于i j之间的数所产生的数列中最大的cycle length。</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">100 </span><span class="hljs-number">200</span><br><span class="hljs-symbol">201 </span><span class="hljs-number">210</span><br><span class="hljs-symbol">900 </span><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">100 </span><span class="hljs-number">200</span> <span class="hljs-number">125</span><br><span class="hljs-symbol">201 </span><span class="hljs-number">210</span> <span class="hljs-number">89</span><br><span class="hljs-symbol">900 </span><span class="hljs-number">1000</span> <span class="hljs-number">174</span><br></code></pre></td></tr></table></figure><h2 id="思路及代码-1"><a href="#思路及代码-1" class="headerlink" title="思路及代码"></a>思路及代码</h2><p>题目需要统计的是使用这个算法的到数列的长度，只需要定义函数判断即可。</p><p>很显然这个算法是一个递归的，可以写成递归的形式来判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> i,j;<br><span class="hljs-keyword">int</span> c ;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cycle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span>(x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) x /= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> x = <span class="hljs-number">3</span> * x + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">cycle</span>(x);<br>    c ++ ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    c = <span class="hljs-number">1</span> ;<br>    <span class="hljs-built_in">cycle</span>(y);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; i &gt;&gt; j)<br>    &#123;<br>        <span class="hljs-keyword">int</span> l = i , r = j ;<br>        <span class="hljs-keyword">int</span> o = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(i &gt; j) <span class="hljs-built_in">swap</span>(j,i);<br>        <span class="hljs-keyword">for</span>(i; i &lt;= j; i ++ )<br>            o = <span class="hljs-built_in">max</span>(o, <span class="hljs-built_in">f</span>(i));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,l,r,o);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-E-进制转换"><a href="#问题-E-进制转换" class="headerlink" title="问题 E: 进制转换"></a>问题 E: 进制转换</h2><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个十进制正整数，然后输出它所对应的八进制数。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>输入一个十进制正整数n(1≤n≤10<em>6</em>) 。</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出n对应的八进制数，输出在一行。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10<br></code></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></table></figure><h2 id="代码及思路-1"><a href="#代码及思路-1" class="headerlink" title="代码及思路"></a>代码及思路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br> <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%o&quot;</span>,num);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-F-排列问题"><a href="#问题-F-排列问题" class="headerlink" title="问题 F: 排列问题"></a>问题 F: 排列问题</h2><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>  输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">abc,</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">abc acb <span class="hljs-keyword">bac </span><span class="hljs-keyword">bca </span>cab cba<br></code></pre></td></tr></table></figure><h2 id="代码及思路-2"><a href="#代码及思路-2" class="headerlink" title="代码及思路"></a>代码及思路</h2><p><strong>思路</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//介绍getline()函数</span><br><span class="hljs-function">istream &amp;<span class="hljs-title">getline</span><span class="hljs-params">( <span class="hljs-keyword">char</span> *buffer, streamsize num, <span class="hljs-keyword">char</span> delim )</span></span>;<br><span class="hljs-function">istream &amp;<span class="hljs-title">getline</span><span class="hljs-params">( <span class="hljs-keyword">char</span> *buffer, streamsize num )</span></span>;<br><span class="hljs-comment">//其中的buffer、num、delim的意思分别为</span><br><span class="hljs-comment">//buffer： 进行读入操作的输入流，num 存储读入的内容，delim 终结符</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">11</span>];<br>    cin.<span class="hljs-built_in">getline</span>(str, <span class="hljs-number">11</span>, <span class="hljs-string">&#x27;,&#x27;</span>);<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; str[x] != <span class="hljs-string">&#x27;\0&#x27;</span>; x++);<br>    <span class="hljs-built_in">sort</span>(str, str + x);<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) &#123;<br>            cout &lt;&lt; str[i];<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(str, str + x));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="问题-H-求第k小"><a href="#问题-H-求第k小" class="headerlink" title="问题 H: 求第k小"></a>问题 H: 求第k小</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出一行，输出第k小数。</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h2 id="思路及代码-2"><a href="#思路及代码-2" class="headerlink" title="思路及代码"></a>思路及代码</h2><p>这道题目是求的第K小的数，通常来讲，第一时间想到的就说做一个排序，然后直接输出第K小就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span> </span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> q[N];<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> x = q[l], i= l - <span class="hljs-number">1</span>,j = r + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i] , q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l , j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span> , r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin&gt;&gt;q[i];<br><br>    <span class="hljs-built_in">quick_sort</span>(q, <span class="hljs-number">0</span> , n - <span class="hljs-number">1</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, q[m<span class="hljs-number">-1</span>]);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然还有一种效率更高的方法，记得老师上课的时候讲过，先空在这里，过会再来填坑。</p><h1 id="问题-I-沙子的质量"><a href="#问题-I-沙子的质量" class="headerlink" title="问题 I: 沙子的质量"></a>问题 I: 沙子的质量</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p><h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p><h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>合并的最小代价。</p><h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">22<br></code></pre></td></tr></table></figure><h2 id="代码及思路-3"><a href="#代码及思路-3" class="headerlink" title="代码及思路"></a>代码及思路</h2><p><strong>思路</strong>：这道题是一道动态规划问题，可以将其划分为就解最优子问题的问题，例如，将其划分为两个方面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">307</span>;<br> <br><span class="hljs-keyword">int</span> s[N];<br><span class="hljs-keyword">int</span> f[N][N];<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; s[i];<br>        s[i] += s[i - <span class="hljs-number">1</span>];<br>    &#125;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == i) &#123;<br>                f[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            f[i][j] = <span class="hljs-number">1e9</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k++) &#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="hljs-number">1</span>][j] + s[j] - s[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="问题-J-最长公共子序列"><a href="#问题-J-最长公共子序列" class="headerlink" title="问题 J: 最长公共子序列"></a>问题 J: 最长公共子序列</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。</p><h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p><h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>最长子串的长度。</p><h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abccd aecd</span><br></code></pre></td></tr></table></figure><h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="代码及思路-4"><a href="#代码及思路-4" class="headerlink" title="代码及思路"></a>代码及思路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N = <span class="hljs-number">2010</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br>string a,b;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (a&gt;=b)  <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> b; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,len_a,len_b;    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    len_a = a.<span class="hljs-built_in">length</span>();<br>    len_b = b.<span class="hljs-built_in">length</span>();      <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= len_a;i ++ )<br>       &#123;<br>       <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span> ;j &lt;= len_b;j ++ )<br>           &#123;<br>           <span class="hljs-keyword">if</span> (a[i<span class="hljs-number">-1</span>] == b[j<span class="hljs-number">-1</span>]) f[i][j] = f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>           &#125;<br>       &#125;     <br>    cout &lt;&lt; f[len_a][len_b];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p><strong>快速幂</strong>（<strong>Exponentiation by squaring</strong>，平方求幂）是一种简单而有效的小算法，它可以以<img src="https://www.zhihu.com/equation?tex=O(%5Clog+n)" alt="[公式]">的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：</strong>最朴素的想法，7<em>7=49，49</em>7=343，… 一步一步算，共进行了<strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：</strong>先算7的5次方，即7<em>7</em>7<em>7</em>7，再算它的平方，共进行了<strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：</strong>先算7<em>7得49，则7的5次方为49</em>49*7，再算它的平方，共进行了<strong>4次</strong>乘法。</p><p>模仿这样的过程，我们得到一个在 <img src="https://www.zhihu.com/equation?tex=O(%5Clog+n)" alt="[公式]"> 时间内计算出幂的算法，也就是快速幂。</p><h2 id="递归快速幂"><a href="#递归快速幂" class="headerlink" title="递归快速幂"></a>递归快速幂</h2><p>刚刚我们用到的，无非是一个<strong>二分</strong>的思路。我们很自然地可以得到一个递归方程：</p><p><img src="https://www.zhihu.com/equation?tex=a%5En=%5Cbegin%7Bcases%7Da%5E%7Bn-1%7D%5Ccdot+a,&%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+odd%7D+%5C%5C+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Ccdot+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D,+&%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+even+but+not+0%7D%5C%5C+1,&%5Ctext%7Bif+%7D+n=0%5Cend%7Bcases%7D" alt="[公式]"></p><p>计算a的n次方，如果n是偶数（不为0），那么就<strong>先计算a的n/2次方，然后平方</strong>；如果n是奇数，那么就<strong>先计算a的n-1次方，再乘上a</strong>；递归出口是<strong>a的0次方为1</strong>。</p><p>递归快速幂的思路非常自然，代码也很简单（直接把递归方程翻译成代码即可）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归快速幂</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(a, n - <span class="hljs-number">1</span>) * a;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">qpow</span>(a, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> temp * temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这个temp变量是必要的，因为如果不把<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D" alt="[公式]">记录下来，直接写成qpow(a, n /2)*qpow(a, n /2)，那会计算两次<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D" alt="[公式]">，整个算法就退化为了 <img src="https://www.zhihu.com/equation?tex=O(n)" alt="[公式]"> 。</p><p>在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是<strong>步步取模</strong>，如果MOD较大，还应当<strong>开long long</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归快速幂（对大素数取模）</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(a, n - <span class="hljs-number">1</span>) * a % MOD;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ll temp = <span class="hljs-built_in">qpow</span>(a, n / <span class="hljs-number">2</span>) % MOD;<br>        <span class="hljs-keyword">return</span> temp * temp % MOD;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家知道，递归虽然<strong>简洁</strong>，但会产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong>。</p><h2 id="非递归快速幂"><a href="#非递归快速幂" class="headerlink" title="非递归快速幂"></a>非递归快速幂</h2><p>我们换一个角度来引入非递归的快速幂。还是7的10次方，但这次，我们把10写成<strong>二进制</strong>的形式，也就是 <img src="https://www.zhihu.com/equation?tex=(1010)_2" alt="[公式]"> 。</p><p>现在我们要计算 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(1010)_2%7D" alt="[公式]"> ，可以怎么做？我们很自然地想到可以把它拆分为 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(1000)_2%7D+%5Ccdot+7%5E%7B(10)_2%7D+" alt="[公式]"> . 实际上，对于任意的整数，我们都可以把它拆成若干个 <img src="https://www.zhihu.com/equation?tex=7%5E%7B(100...)_2%7D" alt="[公式]"> 的形式相乘。而这些<img src="https://www.zhihu.com/equation?tex=7%5E%7B(100...)_2%7D" alt="[公式]">，恰好就是 <img src="https://www.zhihu.com/equation?tex=7%5E1" alt="[公式]"> 、<img src="https://www.zhihu.com/equation?tex=7%5E2" alt="[公式]">、<img src="https://www.zhihu.com/equation?tex=7%5E4" alt="[公式]">……我们只需<strong>不断把底数平方</strong>就可以算出它们。</p><p>我们先看代码，再来仔细推敲这个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//非递归快速幂</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)        <span class="hljs-comment">//如果n的当前末位为1</span><br>            ans *= a;  <span class="hljs-comment">//ans乘上当前的a</span><br>        a *= a;        <span class="hljs-comment">//a自乘</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>;       <span class="hljs-comment">//n往右移一位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>最初ans为1，然后我们一位一位算：</p><p>1010的最后一位是0，所以a^1这一位不要。然后1010变为101，a变为a^2。</p><p>101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为10，a再自乘。</p><p>10的最后一位是0，跳过，右移，自乘。</p><p>然后1的最后一位是1，ans再乘上a^8。循环结束，返回结果。</p><p><img src="https://pic3.zhimg.com/v2-e99e321dcff33699093cde2876424dbe_r.jpg" alt="preview"></p><p>这里的位运算符，**&gt;&gt;<strong>是右移，表示把二进制数</strong>往右移一位<strong>，相当于/2；&amp;是按位与，&amp;1可以理解为</strong>取出二进制数的最后一位**，相当于%2==1。这么一等价，是不是看出了递归和非递归的快速幂的关系了？虽然非递归快速幂因为牵扯到二进制理解起来稍微复杂一点，但基本思路其实和递归快速幂没有太大的出入。</p><h2 id="快速幂的拓展"><a href="#快速幂的拓展" class="headerlink" title="快速幂的拓展"></a>快速幂的拓展</h2><p>上面所述的都是<strong>整数</strong>的快速幂，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。下面给出一个模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//泛型的非递归快速幂</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">qpow</span><span class="hljs-params">(T a, ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    T ans = <span class="hljs-number">1</span>; <span class="hljs-comment">// 赋值为乘法单位元，可能要根据构造函数修改</span><br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>            ans = ans * a; <span class="hljs-comment">// 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = a * a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，<strong>矩阵快速幂</strong>的一个经典应用是求斐波那契数列：</p><p>子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N = <span class="hljs-number">2010</span>;<br><span class="hljs-keyword">int</span> f[N][N];<br>string a,b;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span> (a&gt;=b)  <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> b; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,len_a,len_b;    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    len_a = a.<span class="hljs-built_in">length</span>();<br>    len_b = b.<span class="hljs-built_in">length</span>();      <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= len_a;i ++ )<br>       &#123;<br>       <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span> ;j &lt;= len_b;j ++ )<br>           &#123; <br>           <span class="hljs-keyword">if</span> (a[i<span class="hljs-number">-1</span>] == b[j<span class="hljs-number">-1</span>]) f[i][j] = f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>           &#125;<br>       &#125;     <br>    cout &lt;&lt; f[len_a][len_b];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速幂部分知识摘自于：<a href="https://zhuanlan.zhihu.com/p/95902286">https://zhuanlan.zhihu.com/p/95902286</a></p>]]></content>
    
    
    <categories>
      
      <category>算法OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微机原理实验</title>
    <link href="/2021/09/08/first/"/>
    <url>/2021/09/08/first/</url>
    
    <content type="html"><![CDATA[<h1 id="8255芯片＋8254芯片实现硬延时跑马灯"><a href="#8255芯片＋8254芯片实现硬延时跑马灯" class="headerlink" title="8255芯片＋8254芯片实现硬延时跑马灯"></a>8255芯片＋8254芯片实现硬延时跑马灯</h1><p><strong>仅供参考</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs xml">；此案例中8255的四个端口地址依次为 280H 281H 282H 283H<br>; 8254的依次为 298H 299H 29AH 29BH <br>；8255接Y0 8254接Y3<br>；此程序实现目标，通过开关D0来启动或终止跑马灯，每个灯亮延时2s<br>；这里是用8255的A口来输入8254处理过的脉冲信号，B口输出，C口输入开关状态<br>CODE SEGMENT<br>       ASSUME CS:CODE<br><br>START: <br>       MOV DX,283H<br>       MOV AL,10011001B <br>       OUT DX,AL；向8255写入控制字<br>       <br>-- 初始化8254 使其达到一个2s的延时效果---这里使用了一个级联的方式，使用了1号通道和2号通道级联；<br>       MOV AL,01110101B    ；写入8254 1号通道的控制字<br>       MOV DX,29BH<br>       OUT DX,AL<br>       MOV AL,00H<br>       MOV DX,299H                                      <br>       OUT DX,AL<br>       MOV AL,10H<br>       OUT DX,AL <br>                 <br>       MOV AL,10110111B ；写入8254 2号通道的控制字<br>       MOV DX,29BH<br>       OUT DX,AL<br>       MOV AL,00H<br>       MOV DX,29AH<br>       OUT DX,AL<br>       MOV AL,40H<br>       OUT DX,AL ；初始化结束<br><br>       MOV BL,04H；设定初值，暂存于BL中<br>；读入开关状态，是否是D0接入<br>T1:<br>    MOV DX,282H<br>    IN  AL,DX<br>    TEST AL,01H ；00000001B<br>    JZ T1<br>；读8254输出电平的状态，若为低电平则继续循环，等待高电平到来<br>T2:<br>   MOV DX,280H<br>   IN  AL,DX<br>   TEST AL,01H<br>   JZ T2<br>；前面都准备就绪，开始让第三个灯亮<br>   MOV DX,281H<br>   MOV AL,BL<br>   OUT DX,AL<br> T4:<br>；测试此时是否为高电平，<br>   MOV DX,280H<br>   IN  AL,DX<br>   TEST AL,01H<br>   JNZ T4 <br>；当此刻为高电平，则完成了延时过程，实现了延时2s<br> ；循环左移一位<br>    ROL BL,1<br>    JMP T1  <br><br>CODE ENDS<br>END START<br></code></pre></td></tr></table></figure><p><strong>课程实验总结，仅供参考。</strong></p>]]></content>
    
    
    <categories>
      
      <category>微机原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
